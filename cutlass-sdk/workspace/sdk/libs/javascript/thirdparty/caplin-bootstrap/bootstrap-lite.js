/*
 *  Copyright 1995-2013 Caplin Systems Ltd. Do not edit this file; edits will be lost after upgrades.
 */

if(!window.caplin)
{
	window.caplin = {};
}

caplin._deprecatedClassOrMethodWarningHistory = {};

/**
 * Extends the class definition of the sub class with the class definition of the super class.
 *
 * <p>Subclassing in JavaScript is done by extending the prototype of the sub class with the properties
 * that are defined on the prototype of the super class. The properties on the super class can be any type
 * of JavaScript object, including a standard function object, typically used as a class method,
 * or simply an object, typically used a static member.</p>
 *
 * @param {Variant} vSubClass The class that is extending the superclass. This can be either a reference to the class's constructor or a String representation
 * @param {Variant} vSuperClass The class to be extended. This can be either a reference to the class's constructor or a String representation
 */
caplin.extend = function(vSubClass, vSuperClass)
{
	if (vSubClass == null) { throw new Error("extend: Subclass not specified"); }
	if (vSuperClass == null) { throw new Error("extend: Superclass not specified"); }

	var fSubClass = vSubClass;
	var fSuperClass = vSuperClass;

	if (vSubClass.constructor == String) {
		fSubClass = caplin.getObject(vSubClass);
	}

	if (vSuperClass.constructor == String) {
		fSuperClass = caplin.getObject(vSuperClass);
		caplin.include(vSuperClass, true);
	}

	var bIsFirstInheritance = true;

	// see if the base classes prototype is currently empty
	for(var x in fSubClass.prototype)
	{
		bIsFirstInheritance = false;
		break;
	}

	if(bIsFirstInheritance)
	{
		// single inheritance
		// todo: confirm that using the Function constructor avoids closure, and memory leaks?
		var fIntermediateClass = new Function();

		// instead of inheriting directly from the super class and causing the constructor to be fired with zero
		// arguments, we use an intermediate class with the same prototype as the super class so that the object
		// constructor is avoided altogether
		fIntermediateClass.prototype = fSuperClass.prototype;
		fSubClass["prototype"] = new fIntermediateClass(); // don't use fSubClass.prototype to keep jsdoc happy
	}
	else
	{
		// multiple inheritance
		for(x in fSuperClass.prototype)
		{
			fSubClass.prototype[x] = fSuperClass.prototype[x];
		}
	}
};

/**
 * Extends the class definition of <code>fClass</code> with the interface defined in
 * <code>fInterface</code>.
 *
 * @param {Function} fClass The class that is implementing the interface.
 * @param {Function} fInterface The interface that the class must implement.
 */
caplin.implement = function(fClass, fInterface)
{
	// caplin.implement is an alias for caplin.extend which allows the programmer intention to be expressed more clearly
	caplin.extend(fClass, fInterface);
};

/**
 * Checks that an object instance implements all the public functions of the class (i.e. a duck-typing check).  NB: does not check the entire prototype chain.
 *
 * @param {Object} oInstance An object instance that we are checking.
 * @param {Function} fClass The class or interface we are checking against.
 *
 * @return {boolean} true if the instance is an instance of the class constructed by the function.
 *
 * @throws Error if fClass is not a function.
 */
caplin.isImplementorOf = function(oInstance, fClass)
{
	if (oInstance === null || oInstance === undefined)
	{
		return false;
	}

	if (typeof fClass !== "function" && fClass.prototype.constructor === undefined)
	{
		throw new Error("The constructor must be a function");
	}

	for (var member in fClass.prototype)
	{
		try {
			// We only want to check that the members are functions.
			if (typeof fClass.prototype[member] !== "function")
			{
				continue;
			}
		} catch (e) {
			// We require this for Native javascript types as checking
			continue;
		}

		// Skip private functions.
		if( member.indexOf("_") === 0)
		{
			continue;
		}
		if (oInstance[member] === undefined || oInstance[member] === null)
		{
			return false;
		} else
		{
			// Check to see if the member that we are checking is actually
			// a function, otherwise this is a property, but we were expecting a function.
			if (typeof oInstance[member] !== "function"  && !caplin.isFunctionOnIEWindowOpener(oInstance[member]))
			{
				return false;
			}
		}
	}
	return true;
};

/**
 * Invoked by API methods that have been deprecated. If the unary parameter <code>deprecated</code>
 * is included within the query string of the application web page any invocations of this
 * method will result in an error message being displayed, making it easier to find out which
 * deprecated methods are being used by the application.
 *
 * Remember that we want to be able to pull uses of this method, including the classname, the method
 * name and the date out of our code base using a regex.
 *
 * @param {String} sClassName The name of the class that has been deprecated or the class that the
 *			deprecated method belongs to.
 * @param {String} sMethodName The name of the method that is deprecated. null if the whole class
 *			or constructor has been deprecated.
 * @param {String} sDate The date that this method was deprecated in YYYY-MM-DD format, e.g. "2012-03-20"
 * @param {String} sMessage A message describing the deprecation.  This should explain how code that uses this method should be rewritten.
 */
caplin.deprecated = function(sClassName, sMethodName, sDate, sMessage)
{
	if(this._isDeprecatedEnabled(window.location.search))
	{
		var sKey = sMethodName == null ? sClassName : sClassName + "#" + sMethodName;
		if(this._deprecatedClassOrMethodWarningHistory[sKey] === undefined)
		{
			var sError = sMethodName == null ? 'The class "' + sClassName + '" includes a deprecation warning.' : 'The "' + sMethodName + '()" method on the class "' + sClassName + '" includes a deprecation warning.';

			if(sMessage) {
				sError += " " + sMessage;
			}

			this._logError(sError);
			this._deprecatedClassOrMethodWarningHistory[sKey] = true;
		}
	}
};

/**
 * Determines whether the <code>deprecated</code> parameter has been included within the specified
 * query string or not.
 * @see #deprecated
 * @private
 */
caplin._isDeprecatedEnabled = function(sQueryString)
{
	return (sQueryString.match(/[?&]deprecated([&=]|$)/) !== null);
};

/**
 * @private
 */
caplin._logError = function(sErrorMessage)
{
	if(window.console && console.error)
	{
		console.error(sErrorMessage);
	}
	else
	{
		window.alert(sErrorMessage);
	}
};

/**
 * Invoked by API methods that are no longer supported.
 *
 * @param {String} sClassName The name of the class that is no longer supported or the class that the
 *			unsupported method belongs to.
 * @param {String} sMethodName The name of the method that is no longer supported (Optional: not needed for
 *			constructors).
 */
caplin.unsupported = function(sClassName, sMethodName)
{
	if(!sMethodName)
	{
		throw new Error("The " + sClassName + " class is no longer supported.");
	}
	else
	{
		throw new Error("The " + sClassName + "." + sMethodName + "() method is no longer supported.");
	}
};

caplin.thirdparty = function(sClassName)
{
	// TODO: remove this method completely as it was only introduced recently -- we're going to use pragma comments once
	// js-bundler comment stripping has been disabled (PCTCUT-???)
};

caplin.namespace = function(sPackage)
{
	var pPackageElements = sPackage.split(".");
	var oPackageObject = window;

	for(var n = 0, nLength = pPackageElements.length; n < nLength; n++)
	{
		var sNextPackageElement = pPackageElements[n];

		if (sNextPackageElement == "")
		{
			if(n == nLength - 1)
			{
				continue;
			}
			else
			{
				throw new Error("invalid package argument: " + sPackage);
			}
		}

		if(!oPackageObject[sNextPackageElement])
		{
			oPackageObject[sNextPackageElement] = {};
		}

		oPackageObject = oPackageObject[sNextPackageElement];
	}
};

caplin.include = function(sClassName, bBefore)
{
	caplin.deprecated("caplin", "include", "2012-08-22", "The bundler makes this method unnecessary." );
};

caplin.forceload = function(sClassName)
{
	caplin.deprecated("caplin", "forceload", "2012-08-22", "The bundler makes this method unnecessary." );
};

caplin.singleton = function()
{
	caplin.unsupported("caplin", "singleton");
};

caplin.notifyAfterClassLoad = function()
{
	caplin.unsupported("caplin", "notifyAfterClassLoad");
};

caplin.onLoad = function()
{
	caplin.unsupported("caplin", "onLoad");
};

caplin.addClassPath = function(sClassName, sPath)
{
	caplin.unsupported("caplin", "addClassPath");
};

caplin.loadScript = function(sScriptPath, bSynchronous, sClassName)
{
	caplin.unsupported("caplin", "loadScript");
};

caplin.getClass = function(sClassName)
{
	caplin.deprecated("caplin", "getClass", "2012-08-22", "Use caplin.core.ClassUtility.getClass instead");

	// TODO: implement this method
	return caplin.core.ClassUtility.getClass(sClassName);
};

caplin.getPackage = function(sPackageName)
{
	caplin.deprecated("caplin", "getPackage", "2012-08-22", "Use caplin.core.ClassUtility.getPackage instead");
	return caplin.core.ClassUtility.getPackage(sPackageName);
};

caplin.getObject = function(sObjectName)
{
	caplin.deprecated("caplin", "getObject", "2012-08-22", "Use caplin.core.ClassUtility.getPackage instead");
	return caplin.core.ClassUtility.getPackage(sObjectName);
};

caplin.resolve = function(sFullName, pGlobals)
{
	caplin.unsupported("caplin", "resolve");
};

caplin.getFileContents = function(sFileUrl)
{
	caplin.unsupported("caplin", "getFileContents");
};

caplin.getResourceContents = function(sPackageName, sResourceName)
{
	caplin.unsupported("caplin", "getResourceContents");
};

caplin.getResourceUrl = function(sPackageName, sResourceName)
{
	caplin.unsupported("caplin", "getResourceUrl");
};

caplin.getModuleResourceUrl = function(sPackage, sResource)
{
	caplin.unsupported("caplin", "getModuleResourceUrl");
};

caplin.getPublicResourceUrl = function(sResource)
{
	caplin.unsupported("caplin", "getPublicResourceUrl");
};

caplin.isFunctionOnIEWindowOpener = function (fFunction)
{
	caplin.unsupported("caplin", "isFunctionOnIEWindowOpener");
};

/**
 * Attaches properties to a class's prototype.
 *
 * @private
 */
caplin.defineProperties = function(classConstructor, descriptorObject)
{
	Object.defineProperties(classConstructor.prototype, caplin.createDescriptor(descriptorObject));
};

/**
 * Creates a descriptor object that can be used by the Object.defineProperties/defineProperty/create
 * methods. These methods are used to create classes and/or to do inheritance in JS.
 *
 * @private
 */
caplin.createDescriptor = function(descriptorObject)
{
	var result = {};

	for (var descriptor in descriptorObject)
	{
		result[descriptor] = {
			value: descriptorObject[descriptor],
			enumerable: true
		};
	}

	return result;
};

/**
 * Returns a constructor if the class has already been loaded, else returns a proxy constructor
 * which when called with keyword 'new' will create the required class and pass it back.
 *
 * Will not work for static class methods, can only be used for object construction.
 *
 * @private
 */
caplin.require = function(requiredClass)
{
	try
	{
		return caplin.core.ClassUtility.getClass(requiredClass);
	}
	catch(e)
	{
		return this._getConstructorProxy(requiredClass);
	}
};

/**
 * @private
 */
caplin._getConstructorProxy = function(requiredClass)
{
	return ProxyConstructor;

	function ProxyConstructor() {
		var Constructor = caplin.core.ClassUtility.getClass(requiredClass);

		function Intermediary(args) {
			return Constructor.apply(this, args);
		}
		Intermediary.prototype = Constructor.prototype;

		return new Intermediary(arguments);
	}
};
