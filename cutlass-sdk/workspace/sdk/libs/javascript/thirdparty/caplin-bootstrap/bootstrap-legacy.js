/*
 *  Copyright 1995-2013 Caplin Systems Ltd. Do not edit this file; edits will be lost after upgrades.
 */

/********************************************************************************
 * Class Loading Code
 *******************************************************************************/

if(!window.caplin)
{
	window.caplin = {};
}
if(!caplin.APPLICATION_PROPERTIES)
{
	caplin.APPLICATION_PROPERTIES = {};
}
caplin.bootstrap = {};

caplin.getModuleResourceUrl = function(sPackage, sResource) {
	var pUrl = sPackage.split(".");
	// prepend top-level directory: ["modules", "caplin", <library name>]
	pUrl.unshift("modules", pUrl[0], pUrl[1]);
	pUrl.push(sResource);
	return pUrl.join("/");
}


/**
 * Get URI to publicly available resource from the webapp/public folder.
 * 
 * @param {String} sResource
 */
caplin.getPublicResourceUrl = function(sResource) {
	return ["public",sResource].join("/");
};

/**
 * @private
 */
caplin._nXhrIdx = 0;

/**
 * @private
 */
caplin._oXhrHm = {};

/**
 * @private
 */
 caplin._deprecatedClassOrMethodWarningHistory = {};

/**
 * @type boolean
 * @return <code>true</code> if this is an obfuscated version of the bootstrap library, otherwise
 *         <code>false</code>.
 * @private
 */
caplin.isObfuscated = function(){
	var f = function(oParam) {};
	return f.toString().match("oParam") == null;
};

// Patch definitions form standard DOM constants if missing. IE6/7 needs them.
if (typeof Node == "undefined") {
	var Node = {
		ELEMENT_NODE: 1,
		TEXT_NODE:2,
		DOCUMENT_NODE:9,
		COMMENT_NODE:8,
		DOCUMENT_FRAGMENT_NODE:11,
		ATTRIBUTE_NODE:2
	};
}

/**
 * Flag to control whether we catastrophically fail on errors, or log them and continue working.
 * 
 * <p>Logging errors is correct in production, while failing on errors is useful in the devolpment envrionment.</p>
 * @private
 */
caplin.showErrors = false;

/** @private */
caplin.classLoadingAlertDisplayed = false;

/**
 * @private
 */
caplin.classRoot = "";

/**
 * Map from a package name to the root class path that the class will be loaded from.
 * 
 * @type Object
 * @private
 */
caplin.m_pPackageNameToClassPathMap = {};

/**
 * @private
 */
caplin.m_pLoadingClasses = [];

/**
 * @private
 */
caplin.m_fCheckLoadingClasses = function()
{
	caplin.checkLoadingClasses();
};

/**
 * @private
 **/
caplin.CLASS_LOADING_STATE = {
	SYNC_LOAD: "SYNC_LOAD",
	ASYNC_LOAD: "ASYNC_LOAD",
	LOADED: undefined
};

/**
 * @private
 */
caplin.POLLING_FREQUENCY = 250;

/**
 * @private
 */
caplin.CLASS_LOADER_TIMEOUT = 10000;

/**
 * @private
 */
caplin.STATUS_OK = 200;

/**
 * @private
 */
caplin.m_nTimestamp = -1;

/**
 * Needed to hide window from JsDoc.
 * 
 * @private
 */
caplin.window = null;

/** 
 * @private
 */
caplin.loadingClassesTimeout = false;

/**
 * @private
 */
caplin.m_pOnAfterClassLoadListeners = [];

/** @private */
caplin.pBufferedLogMessages = [];

/**
 * Flag to indicate whether the page has loaded or not. Once the page has loaded, all classes must
 * be loaded synchronously.
 * @private
 */
caplin.m_bPageLoaded = false;

/** @private */
caplin.onLoad = function()
{
	caplin.m_bPageLoaded = true;
	caplin._onAfterClassLoad();
};

if (window.addEventListener)
{
	window.addEventListener("load", caplin.onLoad, false);
}
else if (window.attachEvent)
{
	window.attachEvent("onload", caplin.onLoad);
}

/** @private */
caplin._onAfterClassLoad = function()
{
	var oListener;
	while ((oListener = this.m_pOnAfterClassLoadListeners.shift()) != undefined)
	{
		try
		{
			oListener.onAfterClassLoad();
		}
		catch(e)
		{
			if(console && console.error)
			{
				console.error("Error while invoking onAfterClassLoad() method -- skipping.");
			}
			
			caplin._logError("Error while invoking onAfterClassLoad() method -- skipping.", "ERROR");
			
			if (e.getMessage && (typeof e.getMessage === "function"))
			{
				caplin._logError(e.getMessage(), "ERROR");
				
				if(console && console.error)
				{
					console.error(e.getMessage());
				}
			}
		}
	}
	
	this._changeNotifyAfterClassLoadMethodToImmediateInvocation();
};

/** @private */
caplin._changeNotifyAfterClassLoadMethodToImmediateInvocation = function()
{
	caplin.notifyAfterClassLoad = caplin._immediateOnAfterClassLoadInvocation;
};

/** @private */
caplin._queueOnAfterClassLoadInvocation = function(oListener)
{
//debugger;
	this._validateOnAfterClassLoadListener(oListener);
	this.m_pOnAfterClassLoadListeners.push(oListener);
};

/** @private */
caplin._immediateOnAfterClassLoadInvocation = function(oListener)
{
//debugger;
	this._validateOnAfterClassLoadListener(oListener);
	oListener.onAfterClassLoad();
};

/** @private */
caplin._validateOnAfterClassLoadListener = function(oListener)
{
	if (!oListener || typeof oListener.onAfterClassLoad != "function")
	{
		throw new Error("Specified listener does not implement an onAfterClassLoad() method");
	}
};

/**
 * Registers the specified listener to be notified when all of the classes have been loaded. This
 * is typically required so that a particular class can complete its initialization.
 * 
 * <p>The listener will be notified that all the classes have been loaded by the the invocation of
 * its <code>onAfterClassLoad()</code> method.</p>
 * 
 * <p>If this method is invoked after the classes have been loaded, the listener's
 * <code>onAfterClassLoad()</code> method will be invoked immediately.</p>
 * 
 * <p>The listener's <code>onAfterClassLoad()</code> method must handle any exceptions that would
 * otherwise be passed up the callstack. The behavior of the application is undefined if any
 * listeners <code>onAfterClassLoad()</code> methods throw an exception.</p>
 * 
 * @param {Object} oListener The object to be notified when all of the classes have been loaded. It
 *        must implement a <code>onAfterClassLoad()</code> method.
 * @throws <code>Error</code> if the specified listener does not implement a
 *         <code>onAfterClassLoad()</code> method, or if this method is invoked after the classes
 *         have been loaded and the listener's <code>onAfterClassLoad()</code> method throws an
 *         exception.
 * @private
 */
caplin.notifyAfterClassLoad = function() {};
caplin.notifyAfterClassLoad = caplin._queueOnAfterClassLoadInvocation;   // required for unit tests

/** 
 * @private
 */
caplin.ILLEGAL_NAMESPACE_REGEXP = /[A-Z]/;

/**
 * Creates the specified package if it does not already exist. A package can only be made up
 * of lowercase alphanumeric characters with dots as separators. The package will be converted into
 * a nested group of JavaScript objects, such that the package <code>mybank.core.example</code>
 * will result in object called <code>mybank</code> existing that contains an object called
 * <code>core</code>, which in turn contains an object called <code>example</code>.
 *
 * <p>This method must be invoked with the relevant package before a class can be implemented
 * within that package (please see <a href="writing-your-own-classes.html">Writing Your
 * Own Classes</a> for more information). For example, before the class
 * <code>mybank.foo.Bar</code> is defined, this method must be invoked with the
 * the package <code>mybank.foo</code>.</p>
 *
 * <p>The package that is specified for a class must directly relate to the directory that the
 * class is located within. For example the class <code>mybank.foo.Bar</code>
 * will be found in the source file <code>mybank/foo/Bar.js</code>.</p>
 * 
 * @param {String} sPackage The package to be created.
 * @throws <code>Error</code> if an invalid package is specified, such as one containing an
 *         uppercase character.
 */
caplin.namespace = function(sPackage)
{
	caplin.m_nTimestamp = new Date().getTime();
	
	if(sPackage == ".")
	{
		throw new Error("Invalid package argument \"" + sPackage + "\"");
	}
	else if (sPackage.match(caplin.ILLEGAL_NAMESPACE_REGEXP))
	{
		throw new Error("Invalid package argument \"" + sPackage + "\": a package can only contain lowercase characters");
	}

	var pPackageElements = sPackage.split(".");
	var oPackageObject = window;
	
	for(var n = 0, nLength = pPackageElements.length; n < nLength; n++)
	{
		var sNextPackageElement = pPackageElements[n];
		
		if (sNextPackageElement == "") 
		{
			if(n == nLength - 1)
			{
				continue;
			}
			else 
			{
				throw new Error("invalid package argument: " + sPackage);
			}
		}
		
		if(!oPackageObject[sNextPackageElement])
		{
			oPackageObject[sNextPackageElement] = {};
		}
		
		oPackageObject = oPackageObject[sNextPackageElement];
	}
};


/**
 * Extracts the class paths to be used to load classes within particular packages from the
 * specified configuration string. For example, the string <code>test: /test/source, test.client:
 * source/widget-ext, mybank: /mybank</code> is converted to:
 * 
 * <table>
 * <tr><th>Package</th>     <th>Class Path</th></tr>
 * <tr><td>test</td>        <td>/test/source</td></tr>
 * <tr><td>test.client</td> <td>source/widget-ext</td></tr>
 * <tr><td>mybank</td>     <td>/mybank</td></tr>
 * </table>
 * 
 * <p>With this example, classes that begin <code>test.client</code> will be loaded from the
 * <code>source/widget-ext</code> folder, whilst those that begin <code>test</code> (except those
 * that begin <code>test.client</code>) will be loaded from <code>test/source</code>. Similarly,
 * those classes that begin <code>test.client</code> will be loaded from the <code>/mybank</code>
 * folder.</p>
 * 
 * <p>White space characters will automatically be trimmed from the package and class path
 * values.</p>
 * 
 * @param {String} sExternalClassPaths Comma separated list of the packages and the corresponding
 *        class paths. The package/class path pair is defined using the syntax:
 *        <code><i>{package}</i><b>:</b><i>{class-path}</i></code>.
 * @private
 */
caplin._setExternalClassPaths = function(sExternalClassPaths)
{
	if (typeof sExternalClassPaths == "string")
	{
		// remove all white space from around the comma and colon separators, and at the beginning
		// and end of the string
		sExternalClassPaths = sExternalClassPaths.replace(/\s*,\s*/g, ",").replace(/\s*\:\s*/g, ":").replace(/^\s*/, "").replace(/\s*$/, "");
		
		// split the class paths by the comma
		var pClassPaths = sExternalClassPaths.split(",");
		for (var nPath = 0, nLength = pClassPaths.length; nPath < nLength; ++nPath)
		{
			var oMatch = pClassPaths[nPath].match(/([^:]+)\:(.*)/);
			if (oMatch)
			{
				caplin.addClassPath(oMatch[1], oMatch[2]);
			}
			else
			{
				// TODO: need to log an error
			}
		}
	}
};

/**
 * Adds a mapping between the specified class and the corresponding class path. This defines where
 * the class will be loaded from when it is included (see {@link caplin#include}). The class paths
 * can be defined using the <a href="writing-your-own-classes.html#externalclasspaths"><code>externalclasspaths</code></a>
 * script attribute.
 * 
 * <p>The class path can end with a wild card <code>*</code>, which specified that every class
 * within that package, and every sub package must be loaded from that path. For example, if the
 * class name <code>mybank.*</code> is specified then the classes <code>mybank.Test</code> and
 * <code>mybank.example.HtmlElement</code> will both be loaded from the same location.</p>
 * 
 * <p>If a particular class matches multiple class path definitions then the one with the greater
 * specificity will be used. For example if the class name <code>mybank.*</code> is specified with
 * the path <code>../mybank-source</code> and the class name <code>mybank.example.*</code> has
 * the path <code>../example</code>, then the class <code>mybank.example.HtmlElement</code> will
 * be loaded from the <code>../example</code> folder.</p>
 * 
 * @param {String} sClassName The name of the class to be loaded from the specified path. This
 *        may contain the wild card <code>*</code>.
 * @param {String} sPath The root URL that the specified class will be loaded from. Typically
 *        this is a URL relative to the page loading the class.
 */
caplin.addClassPath = function(sClassName, sPath)
{
	caplin.m_pPackageNameToClassPathMap[sClassName] = sPath;
};

/**
 * Returns the cardinality/number of elements in the given package name. An element refers to each
 * word between the standard '.' seperator in the Package Name. For example, the package 
 * <code>mybank.core</code> has two elements and hence a cardinality of two.
 * 
 * @param {String} sPackageName The name of the package.
 * @type int
 * @return The number of components that make up the specified package name.
 * @private
 */
caplin._getCardinality = function(sPackageName)
{
	return sPackageName.split(".").length;
};

/**
 * Gets the full URL that must be requested to load the specified class. By default, all classes
 * will be loaded from the same location as this <code>caplin</code> class, however the
 * <code>externalclasspaths</code> configuration attribute can be used to define other class
 * paths.
 * 
 * @param {String} sClassName The name of the class.
 * @type String
 * @return The full URL of the class to be loaded.
 * @see caplin#_getFullPackagePath
 * @private
 */
 caplin._getFullClassPath = function(sClassName)
{
	return caplin._getFullPackagePath(sClassName) + ".js";
};

/**
 * Returns the full URL that must be requested to load the specified package.
 * 
 * @param {String} sClassName The name of the class.
 * @type String
 * @return The full URL of the package to be loaded.
 * @private
 */
caplin._getFullPackagePath = function(sPackageName)
{	
	var sFullClassPath;
	
	// use the classRoot by default
	var sPackageRoot = caplin.classRoot;

	// break the package up into its constituent parts then check if there is a class path defined
	// for each part
	var pPackageParts = sPackageName.split(".");
	var sPackageTest = "";
	var nBestMatchCardinality = 0;
	for (var nPart = 0, nLength = pPackageParts.length; nPart < nLength; ++nPart)
	{
		sPackageTest = sPackageTest + ((sPackageTest == "")?"":".") + pPackageParts[nPart];

		// first try an exact match
		if (caplin.m_pPackageNameToClassPathMap[sPackageTest])
		{
			sPackageRoot = caplin.m_pPackageNameToClassPathMap[sPackageTest];
			sFullClassPath = sPackageRoot.replace(/\/$/, "") + "/" + sPackageName.replace(/\./g, "/");
			// this is an exact match on the class name, so break
			break;
		}

		// try a wildcard match
		if (caplin.m_pPackageNameToClassPathMap[sPackageTest + ".*"])
		{
			var nCardinality = caplin._getCardinality(sPackageTest + ".*");
			if (nCardinality > nBestMatchCardinality)
			{
				sPackageRoot = caplin.m_pPackageNameToClassPathMap[sPackageTest + ".*"];
				sFullClassPath = sPackageRoot.replace(/\/$/, "") + "/" + sPackageName.replace(/\./g, "/");
				nBestMatchCardinality = nCardinality;
			}
		}
	}

	if (!sFullClassPath)
	{
		sFullClassPath = caplin.classRoot.replace(/\/$/, "") + "/" + sPackageName.replace(/\./g, "/");
	}
	
	return sFullClassPath;
};

/**
 * @private
 */
caplin.window = window;

/**
 * Checks if the current package has been specified in <code>externalClassPaths</code>.
 * 
 * @param {String} sClassName The name of the class to be checked.
 * @type boolean
 * @return <code>true</code> if the class is in the external classpath, otherwise
 *         <code>false</code>.
 * @private
 */
caplin._isExternalClass = function(sClassName)
{
	var bIsExternalClass = false;
	
	for(var sPackageIter in caplin.m_pPackageNameToClassPathMap)
	{
		var nStarIndex = sPackageIter.indexOf(".*");
		
		if (nStarIndex != -1)
		{
			// wildcard match
			var sExternalPackage = sPackageIter.substr(0, nStarIndex);
			if (sClassName.indexOf(sExternalPackage) == 0 && sClassName != sExternalPackage) 
			{
				bIsExternalClass = true;
				break;
			}
		}
		else
		{
			// exact match
			if (sClassName == sPackageIter)
			{
				bIsExternalClass = true;
				break;
			}
		}
	}
	return bIsExternalClass;
};

/** @private */
caplin.bFirefox3OrGreater = (navigator.appCodeName === "Mozilla")
		&& parseFloat(navigator.userAgent.split('rv:')[1] && navigator.userAgent.split('rv:')[1].split(')')[0], 10) >= 1.9;

/**
 * @private
 */
var sKitTest = "@ISKIT@";

/**
 * @private
 */
var g_bIsWidgetKit = (sKitTest == "true");

/**
 * A directive to the JavaScript Preprocessor defining any dependencies a particular file has with other 
 * JavaScript classes. Calls to this function will be stripped from the source and not be present in the 
 * browser. The class name must correspond to a mapping configured in the JavaScript Preprocessor.
 * 
 * <p>The class that is specified must directly relate to the directory and file name that the
 * class is defined in. Each section of the class namespace is represented by a folder in the
 * operating system, while the file name is that of the class with a <code>.js</code> extension.
 * For example the class <code>mybank.foo.Bar</code> must be specified in the
 * source file <code>mybank/foo/Bar.js</code>.</p>
 * 
 * <p>If the file containing this directive depends on the included class being fully loaded before proceeding, 
 * for example if the class defined in the file is sub-classing, referencing the other class at the global scope
 * or called from a function executed on load, then the <code>bBefore</code> parameter must be set to 
 * <code>true</code>.</p> 
 * 
 * @param {String} sClassName The name of the class to be loaded.
 * @param {boolean} bBefore (Optional) <code>true</code> if the dependent class must be loaded before this class, 
 * otherwise <code>false</code>. If omitted it defaults to <code>false</code>.
 */

caplin.include = function(sClassName, bBefore)
{
	return;
};


/**
 * Similar to caplin.include this forces the JsBundler to load the appropriate file for the
 * classname supplied.
 * 
 * @param {String} sClassName The name of the class to be loaded.
 */

caplin.forceload = function(sClassName)
{
	return;
};

caplin.thirdparty = function(sClassName)
{
    return
};

/**
 * Extends the class definition of the sub class with the class definition of the super class.
 * 
 * <p>Subclassing in JavaScript is done by extending the prototype of the sub class with the properties 
 * that are defined on the prototype of the super class. The properties on the super class can be any type 
 * of JavaScript object, including a standard function object, typically used as a class method, 
 * or simply an object, typically used a static member.</p> 
 *  
 * @param {Function} fSubClass The class that is extending the superclass.
 * @param {Function} fSuperClass The class to be extended.
 */
caplin.extend = function(oSubClass, oSuperClass)
{
	if (oSubClass == null) throw new Error("extend: Subclass not specified");
	if (oSuperClass == null) throw new Error("extend: Superclass not specified");

	var fSubClass;
	
	if (oSubClass.constructor == String) {
		fSubClass = caplin.getObject(oSubClass);
	} else {
		fSubClass = oSubClass;
	}
		
	if (oSuperClass.constructor == String) {
		fSuperClass = caplin.getObject(oSuperClass);
		caplin.include(oSuperClass, true);
	} else {
		fSuperClass = oSuperClass;
	}

	var bIsFirstInheritance = true;
	
	// see if the base classes prototype is currently empty
	for(var x in fSubClass.prototype)
	{
		bIsFirstInheritance = false;
		break;
	}
	
	if(bIsFirstInheritance)
	{
		// single inheritance
		// todo: confirm that using the Function constructor avoids closure, and memory leaks?
		var fIntermediateClass = new Function();
		
		// instead of inheriting directly from the super class and causing the constructor to be fired with zero
		// arguments, we use an intermediate class with the same prototype as the super class so that the object
		// constructor is avoided altogether
		fIntermediateClass.prototype = fSuperClass.prototype;
		fSubClass["prototype"] = new fIntermediateClass(); // don't use fSubClass.prototype to keep jsdoc happy
	}
	else
	{
		// multiple inheritance
		for(x in fSuperClass.prototype) {
			if (!caplin.isAbstractFunction(fSuperClass.prototype[x])) {
				fSubClass.prototype[x] = fSuperClass.prototype[x];
			}
		}
	}
};

/**
 * Extends the class definition of <code>fClass</code> with the interface defined in 
 * <code>fInterface</code>.
 *  
 * @param {Function} fClass The class that is implementing the interface.
 * @param {Function} fInterface The interface that the class must implement.
 */
caplin.implement = function(fClass, fInterface)
{
	// caplin.implement is an alias for caplin.extend which allows the programmer intention to be expressed more clearly
	caplin.extend(fClass, fInterface);
};

/**
 * Constructs an instance of the specified class name and replaces it with the instance object. All
 * static members and methods will still be available once the singleton instance has been created.
 * 
 *  <p><i>Warning - if the specified class contains an instance member or method with the same name
 *  as a static member or method, invoking this method will result in the static member/method
 *  being assigned to the singleton. It is recommended that instance and static members/methods are
 *  given different names to avoid any unexpected behaviors as a result of this.</i></p>
 * 
 * @param {String} sClass The class you want to use as a singleton.
 */
caplin.singleton = function(sClass)
{
	if(typeof(sClass) != "string")
	{
		throw new Error("Class parameter must be a string.");
	}
	
	var nLastDotIndex = sClass.lastIndexOf(".");
	var sPackageName = sClass.substr(0, nLastDotIndex);
	var sClassName = sClass.substr(nLastDotIndex + 1);
	var fClass = caplin.getObject(sClass);
	
	if (typeof fClass == "function")
	{
		var oPackage = caplin.getObject(sPackageName);
		
		// do singleton instrumentation early since we won't get another chance once the class is
		// replaced with the object instance
		fClass = caplin._instrumentClass(fClass, sClass);
		
		// need to store all of the statics added to the class as the following assignment will wipe
		// them out
		var mStaticsToPort = {};
		for (var sStaticName in fClass)
		{
			// ignore prototype - port over all other statics
			if (sStaticName != "prototype")
			{
				mStaticsToPort[sStaticName] = fClass[sStaticName];
			}
		}
		
		oPackage[sClassName] = new fClass();
		
		// now add the statics back in
		for (sStaticName in mStaticsToPort)
		{
			oPackage[sClassName][sStaticName] = mStaticsToPort[sStaticName];
		}
	}
	else
	{
		throw new Error("Class \"" + sClass + "\" is already a singleton object");
	}
};

/**
 * Invoked by API methods that have been deprecated. If the unary parameter <code>deprecated</code>
 * is included within the query string of the application web page any invocations of this
 * method will result in an error message being displayed, making it easier to find out which
 * deprecated methods are being used by the application.
 * 
 * @param {String} sClassName The name of the class that has been deprecated or the class that the 
 * 			deprecated method belongs to.
 * @param {String} sMethodName The name of the method that is deprecated (Optional: not needed for 
 *				constructors).
 */
caplin.deprecated = function(sClassName, sMethodName)
{
	if(this._isDeprecatedEnabled(window.location.search))
	{
		var sKey = sMethodName === undefined ? sClassName : sClassName + "#" + sMethodName;
		if(this._deprecatedClassOrMethodWarningHistory[sKey] === undefined)
		{
			var sError = sMethodName === undefined ? 'The class "' + sClassName + '" has been deprecated' : 'The "' + sMethodName + '()" method on the class "' + sClassName + '" has been deprecated';
			
			this._logError(sError);
			this._deprecatedClassOrMethodWarningHistory[sKey] = true;
		}
	}
};


/**
 * Determines whether the <code>deprecated</code> parameter has been included within the specified
 * query string or not.
 * @see #deprecated
 * @private
 */
caplin._isDeprecatedEnabled = function(sQueryString)
{
	return (sQueryString.match(/[?&]deprecated([&=]|$)/) != null);
};

/**
 * @private
 */
caplin.classLoader = null;

/**
 * Loads the specified class name located in the file as specified in <code>sScriptPath</code>.
 * 
 * @param {String} sScriptPath The full path to the file which contains the class to be loaded.
 * @param {boolean} bSynchronous Whether the class must be loaded immediately, or whether it can
 *        be deferred until later.
 * @param {String} sClassName The full class name to be loaded.
 * @private
 */
caplin.loadScript = function(sScriptPath, bSynchronous, sClassName)
{
	if(bSynchronous || caplin.m_bPageLoaded)
	{
		/**
		 * FF3 issue, description: After doing some investigation, it very much seems as if the XHR objects
		 * created by FF3 occasionally "step" on each other, overwriting one another.
		 * The changes below patches this
		 * 
		 * FF3 issue: we need a unique XHR object for FF3 to load scripts successfully, so we always create a new object without 
		 * checking if the object already exists
		 */
		
		caplin.classLoader = caplin.getXmlHttpRequest();
		/**
		 * FF3 bug: we store the index of the XHR object associated with the script request in
		 * a HashMap
		 */
		caplin._oXhrHm[sScriptPath] = {idx: caplin.classLoader.i}; 

		
		caplin.classLoader.open("GET", sScriptPath, false);
		caplin.classLoader.send("");
		
		if (caplin.classLoader.status === caplin.STATUS_OK)
		{
			/**
			 * FF3 bug: if the index associated originally with the creation of the XHR object (in
			 * 'caplin.getXmlHttpRequest()'doesn't coincide with the index before calling 'open()' on XHR,
			 * we call 'loadScript()' again, which *most likely* resolves the issue because it's so
			 * unlikely that the XHR objects get mixed up again on the subsequent request
			 */			
			if(caplin._oXhrHm[sScriptPath].idx !== caplin.classLoader.i)
			{
				caplin.loadScript(sScriptPath, bSynchronous, sClassName);
			}

			// if the status was OK, then evaluate the response to load the class
			eval(caplin.classLoader.responseText);
		}
		else
		{
			// otherwise log an error, assuming the logger has been loaded
			var sError = "Server error while loading the '" + sClassName + "' class (status " + caplin.classLoader.status + ")";
			if(!caplin._logError(sError, "CRITICAL"))
			{
				if(!caplin.classLoadingAlertDisplayed)
				{
					caplin.classLoadingAlertDisplayed = true;
					alert(sError + " from: " + sScriptPath);
				}
			}
		}
	}
	else
	{
		document.write("<script type='text/javascript' src='" + sScriptPath + "'></script>");
		document.write("<script type='text/javascript'>caplin.checkLoadingClasses(true);</script>");
	}
};

/**
 * @private
 */
caplin._logError = function(sMsg, sLevel)
{
	var bMessageLogged = false;
	
	if(caplin.core && caplin.core.Logger && caplin.core.Logger.log && caplin.core.LogLevel[sLevel])
	{
		caplin.core.Logger.log(caplin.core.LogLevel[sLevel], sMsg);
		bMessageLogged = true;
	}
	else
	{
		caplin.pBufferedLogMessages.push({"sMsg" : sMsg, "sLevel" : sLevel});
	}
	
	return bMessageLogged;
};

/**
 * Returns the contents of the file from the specified URL.
 * 
 * @param {String} sFileUrl The URL of the file to be retrieved.
 * @type String
 * @return The contents of the specified file as text.
 * @throws <code>Error</code> if the specified file cannot be loaded.
 */
caplin.getFileContents = function(sFileUrl)
{
	var oXHR = caplin.getXmlHttpRequest();
	oXHR.open("GET", sFileUrl, false);
	oXHR.send("");
	
	if (oXHR.status === caplin.STATUS_OK)
	{
		// if the status was OK, then evaluate the response to load the class
		return oXHR.responseText;
	}
	else
	{
		throw new Error("Unable to load file " + sFileUrl + " (status " + oXHR.status + ")");
	}
};

/**
 * Returns the contents of the resource in the specified package with the specified resource name.
 * 
 * @param {String} sPackageName The package where the resource file exists, in dot notation (e.g.
 *        <code>mybank.core</code>).
 * @param {String} sResourceName The name of the resource, including its extension.
 * @type String
 * @return The contents of the specified resource file as text.
 * @throws <code>Error</code> if the package or resource names are <code>null</code> or <code>undefined</code>,
 *         or if the specified resource files cannot be loaded.
 * @see caplin#getFileContents
 */
caplin.getResourceContents = function(sPackageName, sResourceName)
{
	return caplin.getFileContents(caplin.getResourceUrl(sPackageName, sResourceName));	
};

/**
 * @private
 */
caplin.getXmlHttpRequest = function()
{
	var oReqObj = false;
	
	if(window.XMLHttpRequest)
	{
		// branch for native XMLHttpRequest object
		try
		{
			oReqObj = new XMLHttpRequest();
			/**
			 * FF3 issue: associate a unique index with each XHR object, which is later used for
			 * cross checking to make sure no mix-up occurs
			 */
			oReqObj.i = caplin._nXhrIdx++;
		}
		catch(e)
		{
			oReqObj = false;
		}
	}
	else if(window.ActiveXObject)
	{
		// branch for IE/Windows ActiveX version
		// WARNING: native library replaces the ActiveXObject for purposes of controlling which XMLHTTP object is created.
		try
		{
			oReqObj = new ActiveXObject("Msxml2.XMLHTTP");
		}
		catch(e)
		{
			try
			{
				oReqObj = new ActiveXObject("Microsoft.XMLHTTP");
			}
			catch(e)
			{
				oReqObj = false;
			}
		}
	}
	
	return oReqObj;
};

/**
 * Gets the URL required to load the resource with the specified name from the location of the
 * specified package.
 * 
 * @param {String} sPackageName The package where the resource file exists, in dot notation (e.g.
 *        <code>mybank.core</code>).
 * @param {String} sResourceName The name of the resource, including its extension.
 * @type String
 * @return The URL required to load the specified resource from the web page this application is
 *         running in.
 * @throws <code>Error</code> if the package or resource names are <code>null</code> or <code>undefined</code>,
 *         or if the specified resource files cannot be loaded.
 * @see caplin#getResourceContents
 */
caplin.getResourceUrl = function(sPackageName, sResourceName)
{
	if (sPackageName === undefined || sPackageName === null)
	{
		throw new Error("caplin.getResourceUrl: the package name argument cannot be null or undefined");
	}
	if (sResourceName === undefined || sResourceName === null)
	{
		throw new Error("caplin.getResourceUrl: the resource name argument cannot be null or undefined");
	}

	var sPackagePath = caplin._getFullPackagePath(sPackageName);
	return sPackagePath + "/" + sResourceName;	
};

/**
 * Returns the inner-most package object for the given package name string.
 * 
 * @param {String} sPackageName
 * @type Object
 * @return the inner most package
 */
// todo: this needs to be unit tested
caplin.getPackage = function(sPackageName)
{
	var pPackageNames = sPackageName.split(".");
	var oPackage = window;
	var sInnerPackage = '';

	if (pPackageNames.length != 1 || pPackageNames[0] != "") {
		// start at the global space (window) and work our way through the packages until we get to the innermost package
		for(var i = 0, l = pPackageNames.length; i < l; ++i)
		{			
			sInnerPackage = pPackageNames[i];
			oPackage = oPackage[sInnerPackage];
			
			if (!(oPackage instanceof Object))
			{
				var sPartialPackagePath = pPackageNames.join(".", i);
				
				throw new Error("'" + sPackageName + "' is not a valid package: failed at '" + sInnerPackage + "'.");
			}
		}
	}

	return oPackage;
};

/**
 * @deprecated Use {@link #getPackage} instead.
 * @private
 */
caplin.getObject = caplin.getPackage;

/**
 * Resolves a global name to an object. It doesn't make any assertion about the types
 * of object leading to the resolved value.
 * This is done without calling eval.
 * 
 * Can replace calls to caplin.webcentric.core.WebcentricAPI.getObject
 * This can be used to resolve constructors.
 *
 * @param {String} sFullName
 * @param {Array} Optional list of global/context objects to try before the window object
 * @throws Error if part of the global name is unknown
 */
caplin.resolve = function(sFullName,pGlobals)
{
    function resolve(global,pName,bThrow) {
        var top = global;
        for(var j=0,n; n = pName[j]; ++j) {
            top = top[n];
            if (top == undefined) {
            	if (bThrow) {
            		throw new Error("The '" + n + "' part of '" + sFullName + "' couldn't be resolved.");
            	}
            	return null;
            }
        }
        return top;
    }
    
    if (pGlobals == undefined) pGlobals = [];
    if (typeof pGlobals == "object" && typeof pGlobals.length == "undefined") pGlobals = [pGlobals];
    var pName = sFullName.split('.');
    for(var i=0,g; g = pGlobals[i]; ++i) {
        var fResolved = resolve(g,pName,false)
        if (fResolved) return fResolved;
    }
    return resolve(window,pName,true);
};


/** @private */
caplin.getClassDefaults = {};
caplin.getClassDefaults[true] = {
	load:true
};
caplin.getClassDefaults[false] = {
	load:false
};

/**
 * Returns the constructor function for a class given the fully qualified class name in string form.
 * 
 * <p>This method does not actually load the class unless the <code>bLoadClass</code> argument is
 * <code>true</code>, in which case the class is loaded synchronously
 * <br>
 * Behaviour for when the class is unknown can be defined; 
 * context:name of what needs the class,
 * unknownClass: function returned instead. 
 * load: Boolean determining whether to attempt loading the class. 
 * singleton: Raise/throw error if the class isn't a singleton.
 * 
 * If no unknownClass is specified an exception will be thrown, otherwise an error will be raised.
 * <pre>
 * caplin.getClass("myapp.SomeClass") - Fetch a loaded class, which isn't a singleton, throw Error if not known.
 * caplin.getClass("myapp.SomeClass",{unknownClass:myapp.Fallback,context:"myapp"}) - Fetch loaded class, use myapp.Fallback if not known, and raise error in log.
 * </pre>
 * (see {@link caplin#include}).</p>
 * 
 * @param {String} sFullClassName The full name of the class.
 * @param {Variant} vLoadClass (Optional) <code>true</code> if this method should ensure that the
 *        specified class is loaded, otherwise <code>false</code>. If a Map is passed details about
 *        handling of unknown class must be specified.
 *        If omitted, it will default to <code>false</code>
 * @type Function
 * @return The constructor for the specified class.
 * @throws <code>Error</code> if the specified class name is not a <code>String</code>.
 */
caplin.getClass = function(sFullClassName, vLoadClass)
{
	if(typeof(sFullClassName) != "string" || sFullClassName.length <= 0)
	{
		throw new Error("caplin.getClass expects input string of length greater than 0\n");
	}
	
	// For true or false expand into object with loading boolean.
	var oLoading = caplin.getClassDefaults[vLoadClass || false] || vLoadClass;
	var sExpectedType = oLoading.singleton? "object":"function";
	
	if (oLoading.load)
	{
		caplin.include(sFullClassName, true);
	}
	
	if(sFullClassName.indexOf(".") == -1)
	{
		var oPackage = window;
		var sClassName = sFullClassName;
	}
	else
	{
		var oPackage = null;
		var sPackageName = sFullClassName.substr(0, sFullClassName.lastIndexOf("."));
		var sClassName = sFullClassName.substr(sFullClassName.lastIndexOf(".") + 1);
		
		try
		{
			oPackage = this.getPackage(sPackageName);
		}
		catch(e)
		{
			throw new Error("'" + sFullClassName + "' unknown as package does not exist\n" + e.toString());
		}
	}

	// Early resolution to optimise the common case
	var fClass = oPackage[sClassName];
	if (typeof fClass == sExpectedType && oLoading.singleton == (fClass.prototype == undefined)) {
		return fClass;
	}
		
	var sMessage = sFullClassName + ": class not known";
	var sMessageSingleton = sFullClassName + ": class must be a singleton";
	if (oLoading.context) {
		sMessage += ", needed by "+oLoading.context;
		sMessageSingleton += " when used by "+oLoading.context;
	}
	sMessage += ". It may need to be added to resources.xml";
	
	fClass = oPackage[sClassName];

	if(typeof(fClass) != sExpectedType)
	{
		if (oLoading.singleton && fClass.prototype != undefined) {
			if (oLoading.unknownClass) {
				caplin.core.Logger.log(caplin.core.LogLevel.ERROR, sMessageSingleton);
				return oLoading.unknownClass;
			}
			throw new Error(sMessageSingleton);		
		}
		
		if (oLoading.unknownClass) {
			caplin.core.Logger.log(caplin.core.LogLevel.ERROR, sMessage);
			return oLoading.unknownClass;
		}
		throw new Error(sMessage);		
	}
	
	return fClass;
};


/**
 * @private
 */
caplin.checkLoadingClasses = function(bIsDirectCall)
{
	var nTimeNow = (new Date()).getTime();
	
	if(!bIsDirectCall)
	{
		caplin.loadingClassesTimeout = false;
	}
	
	// iterate the list of currently loading classes
	for(var i = 0, l = caplin.m_pLoadingClasses.length; i < l; ++i)
	{
		var oLoadingClass = caplin.m_pLoadingClasses[i];
		var sClassName = oLoadingClass.className;
		var sShortClassName = oLoadingClass.shortClassName;
		var oContainingPackage = oLoadingClass.containingPackage;
		var fClass = oContainingPackage[sShortClassName];
		
		if(fClass.caplinLoader === caplin.CLASS_LOADING_STATE.LOADED)
			// this class has succesfully loaded
		{
			// remove class from the loading array
			caplin.m_pLoadingClasses.splice(i, 1);
			--i;
			--l;
			
			// if the user has configured it, add instrumentation to the class so method calls can be logged
			oContainingPackage[sShortClassName] = caplin._instrumentClass(fClass, sClassName);
		}
		else
			// the class has not yet loaded
		{
			// check if the loading timeout has been exceeded
			if((nTimeNow - caplin.m_nTimestamp) > caplin.CLASS_LOADER_TIMEOUT)
			{
				var sError = "timeout while loading the '" + sClassName + "' class";
				
				if(!caplin._logError(sError, "CRITICAL"))
				{
					if(!caplin.classLoadingAlertDisplayed){
						caplin.classLoadingAlertDisplayed = true;
						setTimeout(function() { alert(sError); }, 0);
					}
				}
				
				// remove class from the loading array
				caplin.m_pLoadingClasses.splice(i, 1);
				--i;
				--l;
			}
		}
	}
	
	// set up another polling call back if there are still pending classes
	if((caplin.m_pLoadingClasses.length > 0) && !caplin.loadingClassesTimeout)
	{
		window.setTimeout(caplin.m_fCheckLoadingClasses, caplin.POLLING_FREQUENCY, "class loader");
		caplin.loadingClassesTimeout = true;
	}
};

/** @private */
caplin.m_fAbstractFunction = function() { caplin.abstractFunction(); };

/** @private */
caplin.m_bIsJsUnit = window.location.href.match(/\/jsunit\//) != null;
/**
 * @private
 */
caplin.isJsUnit = function() {
	return caplin.m_bIsJsUnit;
};

/**
 * @private
 */
caplin.isDevelopment = function() {
	return (caplin.APPLICATION_PROPERTIES["CAPLIN.BOOTSTRAP.IS_DEVELOPEMENT"] == true) ? true : false; 
};

/**
 * @private
 *
 * This defines an abstract function.  It should never be called; if it is called, then there is a coding error.
 */
caplin.abstractFunction = function() {
	caplin.core.Logger.log(caplin.core.LogLevel.ERROR, "invocation of unimplemented abstract function");
};

/**
 * @private
 * 
 * Returns true if the specified function is abstract, according to the definition above.
 * 
 * @param {Object} oFunction
 */
caplin.isAbstractFunction = function(oFunction) {
	return oFunction && oFunction.toString().match("caplin\\.abstractFunction");
};


/**
 * @private
 */
// process the scripts configuration parameters
caplin.classRoot = caplin.APPLICATION_PROPERTIES["CAPLIN.CLASS.ROOT"] ? caplin.APPLICATION_PROPERTIES["CAPLIN.CLASS.ROOT"] : "";
caplin._setExternalClassPaths(caplin.APPLICATION_PROPERTIES["CAPLIN.EXTERNAL.CLASS.PATHS"]);

// now load any user specified classes
var sInclude = caplin.APPLICATION_PROPERTIES["CAPLIN.INCLUDE"];
if(sInclude)
{
	var oIncludes = sInclude.split(/\s*,\s*/);
	
	for(var i = 0; i < oIncludes.length; ++i)
	{
		var sClass = oIncludes[i].replace(/\s/g, "");
		
		caplin.include(sClass);
	}
}

//set the classpath, then load bootstrap version
caplin.addClassPath("caplin.bootstrap.*", caplin.APPLICATION_PROPERTIES["CAPLIN.BOOTSTRAP.ROOT"]);

/********************************************************************************
 * Utility Methods
 *******************************************************************************/

/**
 * Utility method to help whilst debugging the application. It allows the composition of an object
 * to be determined from within a debugger.
 * 
 * @param {Object} oObj The object to be inspected.
 * @type String
 * @return A string representation of the object.
 * @private
 */
caplin.inspectObject = function(oObj)
{
	var sReport = "{";
	var bInitialValue = true;
	
	// iterate through all the values in the object and create a json representation of the object
	for(var sKey in oObj)
	{
		var sValue = this._renderArgument(oObj[sKey]);
		
		// comma delimit the values within the object
		if(bInitialValue)
		{
			bInitialValue = false;
		}
		else
		{
			sReport = sReport + ",\n";
		}
		
		// write name/value pair
		sReport = sReport + sKey + ":" + sValue;
	}
	sReport = sReport + "}";
	
	return sReport;
};

/**
 * @private
 */
caplin._renderArgument = function(vArgument, nLevel)
{
	if (nLevel === undefined)
	{
		nLevel = 0;
	}
	
	var sArgument;
	
	if(vArgument === undefined)
	{
		sArgument = "undefined";	
	}
	else if(vArgument === null)
	{
		sArgument = "null";
	}
	else if ((vArgument instanceof Array) || ((vArgument.length !== undefined) && vArgument.context && vArgument.context.xml))
	{
		if (nLevel == 2)
		{
			sArgument = "...";
		}
		else 
		{
			var pArguments = vArgument;
			
			sArgument = "[";
			for (var i = 0, l = pArguments.length; i < l; ++i) 
			{
				if(i > 0)
				{
					sArgument = sArgument + ", ";
				}
				
				sArgument = sArgument + caplin._renderArgument(pArguments[i], nLevel + 1);
			}
			
			sArgument = sArgument + "]";
		}
	}
	else if (vArgument.constructor == Object.prototype.constructor) 
	{
		if (nLevel == 2) 
		{
			sArgument = "...";
		}
		else 
		{
			var oArgument = vArgument;
			var bFirstValue = true;
			
			sArgument = "{";
			
			for (var sKey in oArgument) 
			{
				var vValue = oArgument[sKey];
				
				if(bFirstValue == true)
				{
					bFirstValue = false;
				}
				else
				{
					sArgument = sArgument + ", ";
				}
				
				sArgument = sArgument + sKey + ":" + caplin._renderArgument(vValue, nLevel + 1);
			}
			
			sArgument = sArgument + "}";
		}
	}
	else if (vArgument instanceof Date) 
	{
		sArgument = '"' + vArgument.toDateString() + '"';
	}
	else if(vArgument.ownerDocument && (vArgument.nodeType !== undefined))
		// DOM Element
	{
		sArgument = "&lt;" + vArgument.nodeName + "/&gt;";
	}
	else if ((vArgument instanceof String) || (typeof(vArgument) == "string"))
	{
		sArgument = '"' + caplin._encodeHtml(vArgument) + '"';
	}
	else if (vArgument instanceof Object) 
	{
		var oObject = vArgument;
		var sClass = (oObject.className) ? oObject.className : "Object";
		sArgument = sClass + "(";
		
		if (nLevel == 2) 
		{
			sArgument = sArgument + "...";
		}
		else 
		{
			bFirstValue = true;
			
			for (var sKey in oObject) 
			{
				vValue = oObject[sKey];
				
				if(!(vValue instanceof Function))
				{
					if(bFirstValue == true)
					{
						bFirstValue = false;
					}
					else
					{
						sArgument = sArgument + ", ";
					}
					
					sArgument = sArgument + sKey + ":" + caplin._renderArgument(vValue, nLevel + 1);
				}
			}
		}
		
		sArgument = sArgument + ")";
	}
	else
	{
		try
		{
			sArgument = vArgument.toString();
		}
		catch(e)
		{
			sArgument = "???";
		}
	}
	
	return sArgument;
};

/**
 * @private
 */
caplin._encodeHtml = function(sHtml)
{
	return sHtml.replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/&/gm, "&amp;");
};

/**
 * Checks that an object instance implements all the public functions of the class (i.e. a duck-typing check).  NB: does not check the entire prototype chain.
 * 
 * @param {Object} oInstance An object instance that we are checking.
 * @param {Function} fClass The class or interface we are checking against.
 * 
 * @return true if the instance is an instance of the class constructed by the function.
 * @type boolean
 * 
 * @throws Error if fClass is not a function.
 */
 
// TODO: it is better to apply this duck-typing test within the implement function
// DomC already has some code to do caplin.  Make it work with the entire prototype chain.

caplin.isImplementorOf = function(oInstance, fClass)
{
	if (oInstance === null || oInstance === undefined)
	{
		return false;
	}

	if (typeof fClass !== "function" && fClass.prototype.constructor === undefined)
	{
		throw new Error("The constructor must be a function");
	}

	for (var member in fClass.prototype)
	{
		try {
			// We only want to check that the members are functions.
			if (typeof fClass.prototype[member] != "function")
			{
				continue;
			}
		} catch (e) {
			// We require this for Native javascript types as checking 
			continue;
		}
	
		// Skip private functions.
		if( member.indexOf("_") == 0)
		{
			continue;
		}
		if (oInstance[member] === undefined || oInstance[member] === null)
		{
			return false;
		} else
		{
			// Check to see if the member that we are checking is actually 
			// a function, otherwise this is a property, but we were expecting a function.
			if (typeof oInstance[member] != "function"  && !caplin.isFunctionOnIEWindowOpener(oInstance[member]))
			{
				return false;
			}
		}
	}
	return true;
};

/**
 * Checks if an object meets the unique requirements that no other object meets i.e. that it
 * returns "object" for typeof but false for instanceof Object.  This means it can only be
 * a function on a window.opener instance object in Internet Explorer.
 * 
 * @param {Function} fFunction A function that we are checking.
 * 
 * @return true if the function is a function on a window.opener object in Internet Explorer
 * @type boolean
 * @private
 */
caplin.isFunctionOnIEWindowOpener = function (fFunction)
{
	return (typeof fFunction == "object") && ! (fFunction instanceof Object);
};


/********************************************************************************
 * Tracing Support (Experimental)
 *******************************************************************************/

/**
 * @private
 */
caplin._instrumentClass = function(fClass, sClass)
{
	// don't instrument the same class more than once, and don't instrument the logger at all -- leads to stack overflow
	if ((!this._classIsInstrumented(fClass)) && (sClass != "caplin.component.TraceComponent"))
	{
		var rMethodMatcher = caplin._getMethodMatcher(sClass);
		
		if (rMethodMatcher && (fClass instanceof Function)) 
		{
			var sShortClassName = sClass.substr(sClass.lastIndexOf(".") + 1);
			var pMethods = [];
			
			// instrument the constructor if the user has requested that
			if (rMethodMatcher.test("@")) 
			{
				var fInstrumentedClass = caplin._generateInstrumentedCode(sShortClassName, sShortClassName, null, fClass);
				fInstrumentedClass.prototype = fClass.prototype;
				
				// copy over any static variables/methods
				for (var sItem in fClass) 
				{
					var vItem = fClass[sItem];
					
					fInstrumentedClass[sItem] = vItem;
				}
				
				var fOrigClass = fClass;
				fClass = fInstrumentedClass;
			}
			
			// add the class name to the constructor of all classes so we can provide more detailed parameter tracing
			fClass.className = sClass;
			
			// instrument methods
			this._instrumentMethods(fClass, fOrigClass, sClass, sShortClassName, rMethodMatcher);
			this._instrumentMethods(fClass.prototype, fOrigClass, sClass, sShortClassName, rMethodMatcher);
		}
	}
	
	return fClass;
};

/**
 * @private
 */
caplin._instrumentMethods = function(oMethods, fOwnerClass, sClass, sShortClassName, rMethodMatcher)
{
	for(var sItem in oMethods)
	{
		var vItem = oMethods[sItem];
		
		try
		{
			if ((vItem instanceof Function) && rMethodMatcher.test(sItem)) 
			{
				var bStartsWithLowerCaseLetterOrSymbol = (sItem.match(/^[A-Z]/) == null);
				var bHasEmptyPrototype = true;
				
				for(var x in vItem.prototype)
				{
					bHasEmptyPrototype = false;
					break;
				}
				
				var bIsMethod = bStartsWithLowerCaseLetterOrSymbol && bHasEmptyPrototype;
				
				if (bIsMethod) 
					// method
				{
					caplin._instrumentMethod(oMethods, sShortClassName, sItem);
				}
				else 
					// internal class
				{
					// skip self referential classes
					if (vItem != fOwnerClass)
					{
						oMethods[sItem] = caplin._instrumentClass(vItem, sClass + "." + sItem);
					}
				}
			}
		}
		catch(e)
		{
			// this probably means we are trying to instrument some native object -- ignore and carry on
		}
	}
};

/**
 * @private
 */
caplin._classIsInstrumented = function(fClass)
{
	return fClass && (fClass.className !== undefined);
};

/**
 * @private
 */
caplin._getMethodMatcher = function(sClass)
{
	var pClassMatchers = caplin.pClassMatchers;
	
	for (var i = 0, l = pClassMatchers.length; i < l; ++i) 
	{
		var oClassMatchers = pClassMatchers[i];
		var rClassMatcher = oClassMatchers.classMatcher;
		var rMethodMatcher = oClassMatchers.methodMatcher;
		
		if(rClassMatcher.test(sClass))
		{
			return rMethodMatcher;
		}
	}
};

/**
 * @private
 */
caplin._instrumentMethod = function(fClassPrototype, sShortClassName, sMethod)
{
	var fOriginalMethod = fClassPrototype[sMethod];
	
	fClassPrototype[sMethod] = caplin._generateInstrumentedCode(sShortClassName, sMethod, fOriginalMethod, null);
};

/**
 * Named function used to get around issue where JsDoc was documenting caplin._oTimer, even
 * though it was flagged as private.
 * @private
 */
function NativeTimer()
{
	this.getCurrentTime = function(){
		return new Date().getTime();
	};
	
	this.getDuration = function(nStartTime){
		return (new Date().getTime()) - nStartTime;
	};
};

/**
 * @private
 */
caplin._createTimer = function(sQueryString)
{
	// PCTD-1455 - only attempt to load the IETimer.Clock if traceMethods and/or traceObjects have
	// been specified in the query string 
	if (sQueryString.match(/[&?]trace(Objects|Methods)=[^&]*/) && window.ActiveXObject)
	{
		try
		{
			return new ActiveXObject("IETimer.Clock");
		}
		catch(e)
		{
			return new NativeTimer();
		}
	}
	else
	{
		return new NativeTimer();
	}
};

/**
 * @private
 */
caplin._oTimer = caplin._createTimer(window.location.search);


/**
 * @private
 */
caplin.oLastMethodInfo = null;

/**
 * @private
 */
caplin._generateInstrumentedCode = function(sClass, sMethod, fMethod, fClass)
{
	var oTimer = caplin._oTimer;
	
	return function()
	{
		var oParentMethodInfo = caplin.oLastMethodInfo;
		var bEndOfCallStack = false;
		
		if(!oParentMethodInfo)
		{
			oParentMethodInfo = {innerMethods:[]};
			bEndOfCallStack = true;
		}
		
		// store method call information
		var oMethodInfo = {};
		oMethodInfo.arguments = arguments;
		oMethodInfo.className = sClass;
		oMethodInfo.method = sMethod;
		oMethodInfo.innerMethods = [];
		oParentMethodInfo.innerMethods.push(oMethodInfo);
		caplin.oLastMethodInfo = oMethodInfo;
		
		try 
		{
			var nStartTime = oTimer.getCurrentTime();
			
			// call the actual method
			if(fClass)
			{
				oMethodInfo.returnValue = fClass.apply(this, arguments);
				
				// perform object tracing if configured to do so
				// todo: always do object tracing
				if(caplin.mResidentObjects)
				{
					var pObjects = caplin.mResidentObjects[sClass];
					
					if(!pObjects)
					{
						pObjects = [];
						caplin.mResidentObjects[sClass] = pObjects;
					}
					
					pObjects.push(this);
				}
			}
			else
			{
				oMethodInfo.returnValue = fMethod.apply(this, arguments);
			}
			
			oMethodInfo.duration = oTimer.getDuration(nStartTime);
		}
		catch (e) 
			// there was either an exception or a runtime error while calling the user code -- log it, then rethrow it
		{
			if(!(e instanceof Object))
				// this is Chrome being weird -- it's runtime error objects don't inherit from Object!
			{
				e = new Error(e);
			}
			
			if (e instanceof Error) 
			{
				oMethodInfo.runtimeError = e;
			}
			else 
			{
				oMethodInfo.exception = e;
			}
			
			throw e;
		}
		finally
		{
			caplin.oLastMethodInfo = (bEndOfCallStack) ? null : oParentMethodInfo;
			
			// if we are at the bottom of the call stack then we should re-render the new method call information
			if(bEndOfCallStack && !caplin.bIsCallBeingInstrumented)
			{
				caplin._renderTraceInfo(oMethodInfo);
			}
		}
		
		return oMethodInfo.returnValue;
	};
};

/**
 * @private
 */
caplin._pTraceMethods = [];

/**
 * @private
 */
caplin._renderTraceInfo = function(oMethodInfo)
{
	// just store trace logs till somebody bothers to take an interest
	this._pTraceMethods.push(oMethodInfo);
};

/**
 * @private
 */
function processMethodDefinitions(sMethodDefinitions)
{
	var pMatches = sMethodDefinitions.match(/[?&]traceMethods=([^&]+)/);
	var pClassMatchers = [];
	
	if(pMatches)
	{
		var sMethods = pMatches[1];
		var pMethodDefinitions = sMethods.split(/\s*,\s*/);
		var mClassMatchers = {};
		
		// read all the definitions into a map of classes matchers, each containing an array of methods
		for (var i = 0, l = pMethodDefinitions.length; i < l; ++i) 
		{
			var sMethodDefintion = (pMethodDefinitions[i].indexOf(".") != -1) ? pMethodDefinitions[i] : "." + pMethodDefinitions[i];
			var nMethodIndex = sMethodDefintion.lastIndexOf(".");
			var sClassMatcher = sMethodDefintion.substr(0, nMethodIndex);
			var sMethod = sMethodDefintion.substr(nMethodIndex + 1);
			var pMethods = mClassMatchers[sClassMatcher];
			
			// warn users who forget to add the wildcard to classes
			if(sMethod.match(/^[A-Z]/))
			{
				alert("You probably meant '" + sMethodDefintion + ".*' rather than '" + sMethodDefintion + "'?");
			}
			
			if(!pMethods) 
			{
				pMethods = [];
				mClassMatchers[sClassMatcher] = pMethods;
			}
			
			// convert the wildcards into a regular expression form
			if(sMethod == "*")
			{
				sMethod = "[^_].*";
			}
			else if(sMethod == "_*")
			{
				sMethod = ".*";
			}
			
			pMethods.push(sMethod);
		}
		
		// turn the class and methods into regular expressions for doing the matching quickly
		for(sClassMatcher in mClassMatchers)
		{
			pMethods = mClassMatchers[sClassMatcher];
			sClassMatcher = (sClassMatcher == "*") ? ".*" : sClassMatcher; // support class wildcards
			var rClassMatcher = new RegExp("^" + sClassMatcher);
			var rMethodMatcher = new RegExp("^(" + pMethods.join("|") + ")$");
			
			pClassMatchers.push({classMatcher:rClassMatcher, methodMatcher:rMethodMatcher});
		}
		
		// sort the class matchers so that the most specific class matchers appear first in the list
		pClassMatchers.sort(classMatcherSorter);
	}
	
	return pClassMatchers;
}

/**
 * Added for unit tests, since processMethodDefinitions is obfuscated.
 * @private
 */
caplin._processMethodDefinitions = processMethodDefinitions;

/**
 * @private
 */
function classMatcherSorter(oFirst, oSecond)
{
	return oFirst.classMatcher.length > oSecond.classMatcher.length;
}

/**
 * Parse the instrumentation instructions.
 * @private
 */
caplin.pClassMatchers = processMethodDefinitions(window.location.href);

//experimental object tracing support
if(window.location.href.match(/[?&]traceObjects/))
{
	caplin.pClassMatchers = processMethodDefinitions("?traceMethods=*.@");
	
	/**
	 * @private
	 */
	caplin.mResidentObjects = {};
	var pBuiltinClasses = ["Array", "Boolean", "Error", "EvalError", "Function", "Math", "Number", "Object",
		"RangeError", "ReferenceError", "RegExp", "String", "SyntaxError", "TypeError", "URIError"];
	for(i = 0, l = pBuiltinClasses.length; i < l; ++i)
	{
		sClass = pBuiltinClasses[i];
		var fClass = window[sClass];
		
		window[sClass] = caplin._instrumentClass(fClass, "window." + sClass);
	}
	
	window.setTimeout(function()
	{
		var sReport = "";
		var pClasses = [];
		
		for(var sClass in caplin.mResidentObjects)
		{
			var pObjects = caplin.mResidentObjects[sClass];
			
			pClasses.push({objectCount:pObjects.length, className:sClass});
		}
		
		pClasses.sort(function(o1, o2)
		{
			return (o1.objectCount < o2.objectCount) ? 1 : -1;
		});
		
		for(var i = 0, l = pClasses.length; i < l; ++i)
		{
			var oClass = pClasses[i];
			sClass = oClass.className;
			var nObjectCount = oClass.objectCount;
			
			sReport = sReport + sClass + "(" + nObjectCount + ")\n";
		}
		
		alert(sReport);
	}, 30000);
}


/********************************************************************************
 * Thread Scheduling Support (Experimental)
 *******************************************************************************/

/**
 * @class
 * Class used to improve the behavior of applications on highly saturated machines.
 * 
 * <p>When the browser becomes over saturated due to the rate of updates it receives, two
 * problems can appear which are detrimental to the use of the browser as a real-time
 * trading platform. These are:</p>
 * 
 * <ol>
 *   <li>It's possible for UI events to get queued behind timer & interval events,
 *     decreasing the responsiveness of the application to user input.</li>
 *   <li>It's possible that the screen is not immediately refreshed when new updates are
 *     written to it &mdash; this can not happen untill all pending Javascript has been
 *     executed.</li>  
 * </ol>
 * 
 * @constructor
 * @singleton
 */
caplin.bootstrap.ThreadScheduler = function()
{
	/**
	 * The time soon after which the thread scheduler will yield control so that any pending UI events can be processed.
	 */
	this.UI_EVENT_YIELD_TIME = 50;
	
	/** @private */
	this.m_nNativeTimeoutId;
	/** @private */
	this.m_nNextTimeoutId = 1;
	/** @private */
	this.m_nNextIntervalId = 1;
	/** @private */
	this.m_nTimerCount = 0;
	/** @private */
	this.m_oNextTimer;
	/** @private */
	this.m_mTimers = {};
	/** @private */
	this.m_mBackupTimers = {};
	/** @private */
	this.m_mIntervalMap = {};
	/** @private */
	this.m_pPastTimers;
	/** @private */
	this.m_mAnonymousTimerThreadIds = {};
	/** @private */
	this.m_nAnonymousTimerCount = 0;
	/** @private */
	this.m_mAnonymousIntervalThreadIds = {};
	/** @private */
	this.m_nAnonymousIntervalCount = 0;
	/** @private */
	this.m_nDontProcessTimersUntill;
	/** @private */
	this.m_mThreadPriorities = {};
	/** @private */
	this.m_mPreventExecutionThreads = {};
	/** @private */
	this.m_oDontProcessDataPoint;
	/** @private */
	this.m_nRemoveTimerCount = 0;
	/** @private */
	this.m_nClearIntervalCount = 0;
	/** @private */
	this.m_pThreadQueueListeners = [];
	/** @private */
	this.m_fProcessNextTimeout = this.__processNextTimeout();
	
	// store copies of the original timer methods
	
	
	/** @private */
	this.m_fSetTimeout = window.setTimeout;
	/** @private */
	this.m_fClearTimeout = window.clearTimeout;
	
	
	// ensure the scheduler is enabled
	if (caplin.shouldReplaceNativeTimingFunctions && caplin.shouldReplaceNativeTimingFunctions())
	{
		this._replaceNativeTimingFunctions();
		this._fireExistingTimeoutsAndIntervals();
	}
	
	// some browser sniffing to cope with browser bugs
	if(window.navigator.userAgent.match(/MSIE/))
	{
		/** @private */
		this.m_bIsIE = true;
	}
	
	if(window.navigator.userAgent.match(/Firefox\/3/))
	{
		/** @private */
		this.m_bIsFF3X = true;
	}
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype._replaceNativeTimingFunctions = function()
{
	var oOriginalTimeoutMethods = caplin.getOriginalTimeoutMethods();
	this.m_fSetTimeout = oOriginalTimeoutMethods.setTimeout;
	this.m_fClearTimeout = oOriginalTimeoutMethods.clearTimeout;

	window.setTimeout = this.__setTimeout();
	window.clearTimeout = this.__clearTimeout();
	window.setInterval = this.__setInterval();
	window.clearInterval = this.__clearInterval();
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype._fireExistingTimeoutsAndIntervals = function()
{
	var oTimeoutQueues = caplin.getTimeoutQueues();
	var pTimeouts = oTimeoutQueues.timeouts;
	for(var i = 0; i < pTimeouts.length; ++i)
	{
		var oCurrentTimeout = pTimeouts[i];
		if(oCurrentTimeout)
		{
			this.setTimeout(oCurrentTimeout["function"],oCurrentTimeout["time"],oCurrentTimeout["threadId"]);
		}
		else
		{
			this.m_nNextTimeoutId++;
		}
	}

	var pIntervals = oTimeoutQueues.intervals;
	for(var i = 0; i < pIntervals.length; ++i)
	{
		var oCurrentInterval = pIntervals[i];
		if(oCurrentInterval)
		{
			this.setInterval(oCurrentInterval["function"],oCurrentInterval["time"],oCurrentInterval["threadId"]);
		}
		else
		{
			this.m_nNextIntervalId++;
		}
	}
};

/**
 * A replacement for the native <code>window.setTimeout()</code> method.
 * 
 * <p>This method has the same API as <code>window.setTimeout()</code>, except that it
 * supports an optional <code>sThreadId</code> parameter that helps developers visualize
 * thread usage, and is a pre-requisite for the use of the {@link #preventTimerExecutionAfterThread}
 * method. You do not need to call <code>caplin.bootstrap.ThreadScheduler.setTimeout()</code> directly
 * as it also replaces the native <code>window.setTimeout()</code> method.</p>
 * 
 * @param {Function} fCallback The function that will be invoked once the timeout period has elapsed.
 * @param {int} nTimeout The number of milliseconds until the call-back will be invoked.
 * @param {String} sThreadId A logical name for the thread that is being invoked (Optional).
 * 
 * @type int
 * @return A unique identifier that can be used to cancel this timer using {@link #clearTimeout}.
 */
caplin.bootstrap.ThreadScheduler.prototype.setTimeout = function(fCallback, nTimeout, sThreadId)
{
	nTimeout = parseInt(nTimeout);
	sThreadId = sThreadId || this._generateThreadId(fCallback);
	
	var nTimeoutId = this.m_nNextTimeoutId++;
	var nNextRunTime = new Date().getTime() + nTimeout;
	var nThreadPriority = this._getThreadPriority(sThreadId);
	var oNextTimer = {callback:fCallback, runTime:nNextRunTime, id:nTimeoutId, identifier:sThreadId, threadPriority:nThreadPriority,
		nativeTimeoutIdAtRegistration:this.m_nNativeTimeoutId};
	
	// schedule the next timeout
	if(!this.m_oNextTimer || (nNextRunTime < this.m_oNextTimer.runTime))
		// there is no timer scheduled, or this one is due first
	{
		if(this.m_oNextTimer)
		{
			var fClearTimeout = this.m_fClearTimeout;
			fClearTimeout(this.m_nNativeTimeoutId);
		}
		
		var fSetTimeout = this.m_fSetTimeout;
		this.m_nNativeTimeoutId = fSetTimeout(this.m_fProcessNextTimeout, nTimeout);
		this.m_oNextTimer = oNextTimer;
	}
	else if((nNextRunTime == this.m_oNextTimer.runTime) && (nThreadPriority > this.m_oNextTimer.threadPriority))
		//  this timeout occurs at the same time is the earliest scheduled timer, and has a higher priority -- just
		// update the pointer
	{
		this.m_oNextTimer = oNextTimer;
	}
	
	this._ensureTimerMapIntegrity();
	
	this.m_mTimers[nTimeoutId] = oNextTimer;
	this.m_mBackupTimers[nTimeoutId] = oNextTimer;
	this.m_nTimerCount++;
	
	return nTimeoutId;
};

/**
 * A replacement for the native <code>window.clearTimeout()</code> method.
 * 
 * <p>This method replaces, and has the same API as <code>window.clearTimeout()</code>
 * &mdash; i.e. invoking <code>window.clearTimeout()</code> actually causes this method to be invoked.</p>
 * 
 * @param {int} nTimeoutId The id of the previously registered timeout you wish to cancel.
 */
caplin.bootstrap.ThreadScheduler.prototype.clearTimeout = function(nTimeoutId)
{
	this._ensureTimerMapIntegrity();
	
	if(this.m_mTimers[nTimeoutId])
	{
		this._removeTimer(nTimeoutId);
		
		// clear the global timeout if it is the next timeout being cancelled
		if(this.m_oNextTimer.id == nTimeoutId)
		{
			var fClearTimeout = this.m_fClearTimeout;
			fClearTimeout(this.m_nNativeTimeoutId);
			
			// reschedule the timeout for the next item in the queue
			this._scheduleNextItem();
			this._executeNextItem();
		}
	}
};

/**
 * A replacement for the native <code>window.setInterval()</code> method.
 * 
 * <p>This method has the same API as <code>window.setInterval()</code>, except that it
 * supports an optional <code>sThreadId</code> parameter that helps developers visualize
 * thread usage, and is a pre-requisite for the use of the {@link #preventTimerExecutionAfterThread}
 * method. You do not need to call <code>caplin.bootstrap.ThreadScheduler.setInterval()</code> directly
 * as it also replaces the native <code>window.setInterval()</code> method.</p>
 * 
 * @param {Function} fCallback The function that will be invoked each time the the interval elapses.
 * @param {int} nInterval The number of milliseconds between each invocation of the call-back.
 * @param {String} sThreadId A logical name for the thread that is being invoked (Optional).
 * 
 * @type int
 * @return A unique identifier that can be used to cancel this interval using {@link #clearInterval}.
 */
caplin.bootstrap.ThreadScheduler.prototype.setInterval = function(fCallback, nInterval, sThreadId)
{
	sThreadId = sThreadId || this._generateThreadId(fCallback, true);
	
	// if the callback is a string that needs evaling, rather than a function, convert it to a function permanently
	// so we don't have to perform an instanceof each time round
	if(!(fCallback instanceof Function))
	{
		fCallback = this._generateEvalFunction(fCallback);
	}
	
	// set the first timeout, and map a reference against the interval id so the interval can be cancelled
	var nIntervalId = this.m_nNextIntervalId++;
	var fIntervalHandler = this.__intervalHandler(fCallback, nInterval, sThreadId, nIntervalId);
	this.m_mIntervalMap[nIntervalId] = this.setTimeout(fIntervalHandler, nInterval, sThreadId);

	return nIntervalId;
};

/**
 * A replacement for the native <code>window.clearInterval()</code> method.
 * 
 * <p>This method replaces, and has the same API as <code>window.clearInterval()</code>
 * &mdash; i.e. invoking <code>window.clearInterval()</code> actually causes this method to be invoked.</p>
 * 
 * @param {int} nIntervalId The id of the previously registered interval you wish to cancel.
 */
caplin.bootstrap.ThreadScheduler.prototype.clearInterval = function(nIntervalId)
{
	var nTimeoutId = this.m_mIntervalMap[nIntervalId];
	
	if(nTimeoutId !== undefined)
	{
		// permanently delete this interval
		delete this.m_mIntervalMap[nIntervalId];
		this._cleanMapPeriodically("m_mIntervalMap", "m_nClearIntervalCount");
		
		// clear the next timer related to this interval
		this.clearTimeout(nTimeoutId);
	}
};

/**
 * Define the priorities with which threads will be scheduled.
 * 
 * <p>The following example prioritizes two named threads, while another thread is explicitly de-prioritized:</p>
 * 
 * <pre>
 * caplin.bootstrap.ThreadScheduler.setThreadPriorities([
 *     "highest-priority-thread",
 *     "high-priority-thread",
 *     "*",
 *     "lowest-priority-thread"]);
 * </pre>
 * 
 * @param {Array} pThreadIds A list of thread identifiers, in priority order &mdash; a wildcard thread identifier (i.e. '*') can be used to explicitly de-prioritize any threads specified after that point.
 */
caplin.bootstrap.ThreadScheduler.prototype.setThreadPriorities = function(pThreadIds)
{
	this.m_mThreadPriorities = {};
	var nDefaultIndex = pThreadIds.length;
	
	// find out the priority of unspecified threads
	for(var i = 0, l = pThreadIds.length; i < l; ++i)
	{
		if(pThreadIds[i] == "*")
		{
			nDefaultIndex = i;
			break;
		}
	}
	
	// store the thread priorities in a map [A, *, B] => {A:1, B:-1}
	for(var i = 0, l = pThreadIds.length; i < l; ++i)
	{
		if(i != nDefaultIndex)
		{
			var nThreadPriority = (i < nDefaultIndex) ? nDefaultIndex - i : -(i - nDefaultIndex);
			var sThreadId = pThreadIds[i];
			
			this.m_mThreadPriorities[sThreadId] = nThreadPriority;
		}
	}
};

/**
 * Prevent execution of all timeouts and intervals for the specified period of time.
 * 
 * @see preventTimerExecutionAfterThread
 * 
 * @param {int} nTimeout The number of milliseconds for which timer execution will be prevented.
 */
caplin.bootstrap.ThreadScheduler.prototype.preventTimerExecutionFor = function(nTimeout)
{
	this.m_nDontProcessTimersUntill = new Date().getTime() + nTimeout;
};

/**
 * Prevent execution of all timeouts and intervals, for the specified period of time, after a thread
 * with the given id is executed.
 * 
 * <p>The primary purpose of this method (and {@link #preventTimerExecutionFor}) are to ensure that
 * Javascript execution pauses for enough time to allow the browser to update the screen. Typically,
 * this will only need to occur after the execution of any display updating threads, for example
 * 'display throttle' and 'SL4B update batcher'.</p>
 * 
 * <p>By default, <code>ThreadScheduler</code> does not control the execution of UI events, and so
 * is unable to ensure screen refreshes occur if any long running UI events are running at the same
 * time. It is therefore the responsibility of application developers to ensure that any long running
 * UI events defer their operation using <code>window.setTimeout()</code>, also bringing these threads
 * under the control of <code>ThreadScheduler</code>.</p>
 * 
 * @param {String} sThreadId The name of the thread after which timer execution should be prevented.
 * @param {int} nTimeout The number of milliseconds timer execution will be prevented for.
 */
caplin.bootstrap.ThreadScheduler.prototype.preventTimerExecutionAfterThread = function(sThreadId, nTimeout)
{
	this.m_mPreventExecutionThreads[sThreadId] = nTimeout;
};

/**
 * Add a listener to be informed of updates to the current number of pending and due threads awaiting processing
 * 
 * @param {caplin.bootstrap.ThreadQueueListener} oListener The object that will receive the call-back events.
 */
caplin.bootstrap.ThreadScheduler.prototype.addThreadQueueListener = function(oListener)
{
	this.m_pThreadQueueListeners.push(oListener);
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype._getThreadPriority = function(sThreadId)
{
	var nThreadPriority = this.m_mThreadPriorities[sThreadId];
	
	return (nThreadPriority === undefined) ? 0 : nThreadPriority;
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype._removeTimer = function(nTimeoutId)
{
	this._ensureTimerMapIntegrity();
	
	delete this.m_mTimers[nTimeoutId];
	delete this.m_mBackupTimers[nTimeoutId];
	this._cleanMapPeriodically("m_mTimers", "m_nRemoveTimerCount");
	this.m_nTimerCount--;
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype._processNextTimeout = function(nBatchStartTime)
{
	var nStartTime = new Date().getTime();
	var nBatchStartTime = (nBatchStartTime !== undefined) ? nBatchStartTime : nStartTime;
	var oDataPoint;
	
	if(this._timerRescheduledTillLater(nStartTime))
	{
		return;
	}
	
	if(this.m_pPastTimers)
	{
		var sDisplayName = this.m_oNextTimer.identifier + " (req-id " + this.m_oNextTimer.id + ")";
		oDataPoint = {id:this.m_oNextTimer.identifier, displayName:sDisplayName, startTime:nStartTime};
	}
	
	this._removeTimer(this.m_oNextTimer.id);
	
	try
	{
		if(this.m_oNextTimer.callback instanceof Function)
		{
			var fCallback = this.m_oNextTimer.callback;
			
			fCallback();
		}
		else
		{
			eval(this.m_oNextTimer.callback);
		}
	}
	catch(e)
	{
		caplin._logError("Exception caught after invoking timer: " + e, "ERROR");
	}
	
	var nPreventExecutionFor = this.m_mPreventExecutionThreads[this.m_oNextTimer.identifier];
	
	this._scheduleNextItem();
	
	if(this.m_pPastTimers)
	{
		oDataPoint.endTime = new Date().getTime();
		this.m_pPastTimers.push(oDataPoint);
		
		// if 1s has elapsed
		if(this.m_pPastTimers[this.m_pPastTimers.length - 1].endTime > (this.m_pPastTimers[0].startTime + 1000))
		{
			caplin.bootstrap.ThreadVisualizer._$renderDataPoints(this.m_pPastTimers);
			this.m_pPastTimers = [];
		}
	}
	
	if(nPreventExecutionFor)
	{
		this.preventTimerExecutionFor(nPreventExecutionFor);
	}
	
	this._executeNextItem(nBatchStartTime);
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype._timerRescheduledTillLater = function(nStartTime)
{
	var bRescheduled = false;
	
	// if we've been told not to process any timers right now, then reschedule this timer until after that point
	if(this.m_nDontProcessTimersUntill)
	{
		if(this.m_nDontProcessTimersUntill > nStartTime)
		{
			var nTimeout = this.m_nDontProcessTimersUntill - nStartTime;
			var fSetTimeout = this.m_fSetTimeout;
			this.m_nNativeTimeoutId = fSetTimeout(this.m_fProcessNextTimeout, nTimeout);
			
			if(this.m_pPastTimers && !this.m_oDontProcessDataPoint)
			{
				var sIdentifier = "prevent timer execution";
				
				this.m_oDontProcessDataPoint = {id:sIdentifier, displayName:sIdentifier, startTime:nStartTime, endTime:this.m_nDontProcessTimersUntill};
			}
			
			// return early since we will be processing the remainder of this function at a future point
			bRescheduled = true;
		}
		else
		{
			if(this.m_pPastTimers && this.m_oDontProcessDataPoint)
			{
				this.m_pPastTimers.push(this.m_oDontProcessDataPoint);
			}
			
			this.m_nDontProcessTimersUntill = null;
			this.m_oDontProcessDataPoint = null;
		}
	}
	
	return bRescheduled;
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype._scheduleNextItem = function()
{
	var nCurrentTime = new Date().getTime();
	var oCandidateTimer = null;
	var nTotalTimers = 0;
	var nDueTimers = 0;
	
	this._ensureTimerMapIntegrity();
	
	// find the next timer that should be executed
	for(var nTimeoutId in this.m_mTimers)
	{
		var oTimer = this.m_mTimers[nTimeoutId];
		
		if(!oCandidateTimer || (oTimer.runTime < oCandidateTimer.runTime) ||
			((oTimer.runTime === oCandidateTimer.runTime) && (oTimer.threadPriority > oCandidateTimer.threadPriority)))
		{
			oCandidateTimer = oTimer;
		}
		
		if(oTimer.runTime < nCurrentTime)
		{
			nDueTimers++;
		}
		
		nTotalTimers++;
	}
	this.m_oNextTimer = oCandidateTimer;
	
	this._informThreadQueueListeners(nDueTimers, nTotalTimers);
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype._executeNextItem = function(nBatchStartTime)
{
	var nCurrentTime = new Date().getTime();
	
	if(this.m_oNextTimer)
	{
		var nTimeout = Math.max(0, this.m_oNextTimer.runTime - nCurrentTime);
		var nElapsedTime = nCurrentTime - nBatchStartTime;
		if ((nTimeout === 0) && (nBatchStartTime !== undefined) && (nElapsedTime < this.UI_EVENT_YIELD_TIME) &&
			(this.m_oNextTimer.nativeTimeoutIdAtRegistration != this.m_nNativeTimeoutId))
		{
			this.m_fProcessNextTimeout(null, nBatchStartTime);
		}
		else
		{
			var fSetTimeout = this.m_fSetTimeout;
			this.m_nNativeTimeoutId = fSetTimeout(this.m_fProcessNextTimeout, nTimeout);
		}
	}
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype._informThreadQueueListeners = function(nDueTimers, nTotalTimers)
{
	for(var i = 0, l = this.m_pThreadQueueListeners.length; i < l; ++i)
	{
		var oThreadListener = this.m_pThreadQueueListeners[i];
		
		oThreadListener.onThreadQueueUpdate(nDueTimers, nTotalTimers);
	}
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype._generateEvalFunction = function(sCallback)
{
	return function()
	{
		eval(sCallback);
	};
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype.__intervalHandler = function(fCallback, nInterval, sThreadId, nIntervalId)
{
	var nScheduledTime = new Date().getTime() + nInterval;
	var oThis = this;
	
	var fIntervalHandler = function()
	{
		var e;
		
		// first evaluate the interval function
		try
		{
			fCallback();
		}
		catch(e)
		{
			// do nothing at the moment -- we'll re-throw this later
		}
		
		// register another timeout if this interval is still registered
		if(oThis.m_mIntervalMap[nIntervalId] !== undefined)
		{
			var nCurrentTime = new Date().getTime();
			do // move ahead by at least one interval (FF sometimes fires the timer ahead of the due time which causes bugs)
			{
				nScheduledTime += nInterval;
			} while(nScheduledTime <= nCurrentTime);
			
			// set the next timeout, and keep a reference mapped against the interval id so the interval can be cancelled
			oThis.m_mIntervalMap[nIntervalId] = oThis.setTimeout(fIntervalHandler, nScheduledTime - nCurrentTime, sThreadId);
		}
		
		// if an exception occurred within the interval call-back function then re-throw it now so it acts as normal
		if(e)
		{
			throw e;
		}
	};
	
	return fIntervalHandler;
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype._generateThreadId = function(fCallback, bIsInterval)
{
	var mThreadIds = (bIsInterval) ? this.m_mAnonymousIntervalThreadIds : this.m_mAnonymousTimerThreadIds;
	var sThreadId = mThreadIds[fCallback.toString()];
	
	if(!sThreadId)
	{
		var sType = (bIsInterval) ? "interval" : "timeout";
		var nCount = (bIsInterval) ? ++this.m_nAnonymousIntervalCount : ++this.m_nAnonymousTimerCount;
		
		sThreadId = "anonymous " + sType + " " + nCount;
		mThreadIds[fCallback.toString()] = sThreadId;
	}
	
	return sThreadId;
};

/**
 * @private
 * Prevents a memory leak in IE6 and IE7 where long running maps cause memory use to slowly grow forever.
 */
caplin.bootstrap.ThreadScheduler.prototype._cleanMapPeriodically = function(sMapName, sCountName)
{
	if(this.m_bIsIE)
	{
		if(this[sCountName]++ >= 1000)
		{
			var mSrcMap = this[sMapName];
			var mDestMap = {};
			this[sMapName] = mDestMap;
			this[sCountName] = 0;
			
			for(var sKey in mSrcMap)
			{
				mDestMap[sKey] = mSrcMap[sKey];
			}
		}
	}
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype.__processNextTimeout = function()
{
	var oThis = this;
	
	return function(nFirefoxArgumentIgnore, nStartTime)
	{
		oThis._processNextTimeout(nStartTime);
	};
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype.__setTimeout = function()
{
	var oThis = this;
	
	return function(fCallback, nTimeout, sThreadId)
	{
		return oThis.setTimeout(fCallback, nTimeout, sThreadId);
	};
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype.__clearTimeout = function()
{
	var oThis = this;
	
	return function(nTimeoutId)
	{
		return oThis.clearTimeout(nTimeoutId);
	};
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype.__setInterval = function()
{
	var oThis = this;
	
	return function(fCallback, nInterval, sThreadId)
	{
		return oThis.setInterval(fCallback, nInterval, sThreadId);
	};
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype.__clearInterval = function()
{
	var oThis = this;
	
	return function(nIntervalId)
	{
		return oThis.clearInterval(nIntervalId);
	};
};

/**
 * @private
 */
caplin.bootstrap.ThreadScheduler.prototype._ensureTimerMapIntegrity = function(sPointName)
{
	if(this.m_bIsFF3X && caplin.core && caplin.core.MapUtility && caplin.core.Logger)
	{
		if(caplin.core.MapUtility.size(this.m_mTimers) != this.m_nTimerCount)
		{
			caplin.core.Logger.log(caplin.core.LogLevel.WARN, "Timer map corrupted (Firefox 3.X error) -- restoring from backup.");
			
			var mNewPrimaryMap = {};
			caplin.core.MapUtility.copy(this.m_mBackupTimers, mNewPrimaryMap);
			this.m_mTimers = mNewPrimaryMap;
		}
	}
};

caplin.singleton("caplin.bootstrap.ThreadScheduler");

/**
 * @class
 * Interface implemented by classes wishing to know the current number of pending and due threads awaiting processing.
 * 
 * @interface
 */
caplin.bootstrap.ThreadQueueListener = function()
{
};

/**
 * Call-back that fires each time a thread timer is processed, and the thread queue information changes.
 * 
 * @param {int} nDueTimers The number of registered timers (including intervals) that are now ready to be processed.
 * @param {int} nTotalTimers The total number of registered timers and intervals &mdash; both overdue, and not
 * yet requiring processing.
 */
caplin.bootstrap.ThreadQueueListener.prototype.onThreadQueueUpdate = function(nDueTimers, nTotalTimers)
{
};

/**
 * @class
 * <code>ThreadVisualizer</code> allows the scheduling information generated by {@link caplin.bootstrap.ThreadScheduler}
 * to be visualized as a graphical time-line.
 * 
 * <p>This singleton object does not need to be interacted with programatically. Developers wishing to view
 * threading information can do so by pressing Alt-X (to view a graphical time-line) and Alt-Shift-X
 * (to view a key of anonymous timers and intervals).</p>
 * 
 * @constructor
 * @singleton
 */
caplin.bootstrap.ThreadVisualizer = function()
{
	/** @private */
	this.PIXELS_PER_SECOND = 798;
	/** @private */
	this.m_eDisplayAreaContainer;
	/** @private */
	this.m_eKeyArea;
	/** @private */
	this.m_eDisplayArea;
	/** @private */
	this.m_nNextIdNumber;
	/** @private */
	this.m_mPointIds;
	/** @private */
	this.m_nStartTime;
	/** @private */
	this.m_nLastEndTime;
	
	var fKeyDownListener = this.__keyDownListener();
	if(window.addEventListener)
	{
		window.addEventListener("keydown", fKeyDownListener, true);
	}
	else
	{
		document.attachEvent("onkeydown", fKeyDownListener);
	}
};

/**
 * @private
 */
caplin.bootstrap.ThreadVisualizer.prototype._$renderDataPoints = function(pDataPoints)
{
	if(!this.m_eDisplayArea)
	{
		this.m_eDisplayArea = document.getElementById("visualizerDisplayArea");
		
		this._$clearDataPoints();
	}
	
	if(pDataPoints.length > 0)
	{
		if(this.m_nStartTime === null)
		{
			this.m_nStartTime = pDataPoints[0].startTime;
			this.m_nLastEndTime = this.m_nStartTime;
		}
		
		for(var i = 0, l = pDataPoints.length; i < l; ++i)
		{
			var oDataPoint = pDataPoints[i];
			
			// only render additional data points that appear after the last rendered update
			if(oDataPoint.startTime >= this.m_nLastEndTime)
			{
				var eDataPoint = document.createElement("div");
				
				this.m_nLastEndTime = oDataPoint.endTime;
				
				// styling shared between the composite data point and the specific data point
				var nNormalizedStartTime = oDataPoint.startTime - this.m_nStartTime;
				var nNormalizedEndTime = oDataPoint.endTime - this.m_nStartTime;
				eDataPoint.style.left = Math.ceil((nNormalizedStartTime / 1000) * this.PIXELS_PER_SECOND) + "px";
				eDataPoint.style.width = Math.max(2, Math.floor(((oDataPoint.endTime - oDataPoint.startTime) / 1000) * this.PIXELS_PER_SECOND)) + "px";
				eDataPoint.title = oDataPoint.displayName + "\n" +
					"  duration: " + (oDataPoint.endTime - oDataPoint.startTime) + "ms\n" +
					"  started at: " + nNormalizedStartTime + "ms from start\n" +
					"  ended at: " + nNormalizedEndTime + "ms from start";
				
				// header data point styling
				var eHeaderDataPoint = eDataPoint.cloneNode(false);
				eHeaderDataPoint.className = "id0";
				
				// specific data point styling
				if(!this.m_mPointIds[oDataPoint.id])
				{
					this.m_mPointIds[oDataPoint.id] = this.m_nNextIdNumber++;
				}
				eDataPoint.style.top = 20 * this.m_mPointIds[oDataPoint.id] + "px";
				eDataPoint.className = "id" + this.m_mPointIds[oDataPoint.id];
				
				// append the new html
				if(this.m_eDisplayArea)
				{
					this.m_eDisplayArea.appendChild(eHeaderDataPoint);
					this.m_eDisplayArea.appendChild(eDataPoint);
				}
			}
		}
	}
};

/**
 * @private
 */
caplin.bootstrap.ThreadVisualizer.prototype._$clearDataPoints = function()
{
	this.m_nNextIdNumber = 1;
	this.m_mPointIds = {};
	this.m_nStartTime = null;
	this.m_nLastEndTime = null;
	if(this.m_eDisplayArea)
	{
		this.m_eDisplayArea.innerHTML = "";
	}
};

/**
 * @private
 */
caplin.bootstrap.ThreadVisualizer.prototype.__keyDownListener = function()
{
	var oThis = this;
	
	return function(oEvent)
	{
		oThis._keyDownListener(oEvent);
	};
};

/**
 * @private
 */
caplin.bootstrap.ThreadVisualizer.prototype._keyDownListener = function(oEvent)
{
	// popup visualizer on Alt-X
	if(oEvent.altKey && !oEvent.shiftKey && (oEvent.keyCode == 88))
	{
		if(caplin.bootstrap.ThreadScheduler.m_pPastTimers)
		{
			caplin.bootstrap.ThreadScheduler.m_pPastTimers = null;
			this.m_eDisplayArea = null;
			
			if(this.m_eDisplayAreaContainer)
			{
				this.m_eDisplayAreaContainer.parentNode.removeChild(this.m_eDisplayAreaContainer);
			}
		}
		else
		{
			caplin.bootstrap.ThreadScheduler.m_pPastTimers = [];
			this.m_eDisplayAreaContainer = document.createElement("div");
			this.m_eDisplayAreaContainer.id = "visualizerDisplayAreaContainer";
			this.m_eDisplayAreaContainer.innerHTML = '<div id="visualizerDisplayArea"></div>';
			document.body.appendChild(this.m_eDisplayAreaContainer);
		}
	}
	
	// popup anonymous timer key on Alt-Shift-X
	if(oEvent.altKey && oEvent.shiftKey && (oEvent.keyCode == 88))
	{
		if(this.m_eKeyArea)
		{
			this.m_eKeyArea.parentNode.removeChild(this.m_eKeyArea);
		}
		else
		{
			var pReport = ["<table><th>Thread Name</th><th>Callback Function</th>"];
			
			this._printIdentifiers(pReport, caplin.bootstrap.ThreadScheduler.m_mAnonymousIntervalThreadIds);
			this._printIdentifiers(pReport, caplin.bootstrap.ThreadScheduler.m_mAnonymousTimerThreadIds);
			
			pReport.push("</table>");
			
			this.m_eKeyArea = document.createElement("div");
			this.m_eKeyArea.id = "visualizerKeyArea";
			this.m_eKeyArea.innerHTML = pReport.join("");
			
			document.body.appendChild(this.m_eKeyArea);
		}
	}
};

/**
 * @private
 */
caplin.bootstrap.ThreadVisualizer.prototype._printIdentifiers = function(pReport, mAnonymousThreadIds)
{
	for(var sCallback in mAnonymousThreadIds)
	{
		var sName = mAnonymousThreadIds[sCallback];
		
		pReport.push("<tr><td>" + sName + "</td><td>" + sCallback + "</td>");
	}
};
caplin.singleton("caplin.bootstrap.ThreadVisualizer");


/**
 * @private
 */
caplin._logOnError = function(sMessage, sFilename, sLineNumber)
{
	sMessage = "Javascript Error: " + sMessage;
	if(sFilename && sFilename.length > 0)
	{
		sMessage += " (at line " + sLineNumber + " of '" + sFilename + "')";	
	}
	caplin._logError(sMessage, "ERROR");
};

/**
 * @private 
 */
if(!caplin.isDevelopment())
{
	window.onerror = caplin._logOnError;
}

caplin.onLoad = caplin._onAfterClassLoad;
caplin._onAfterClassLoad = function(){};

caplin.singletons = {}; // from singleton-store.js
caplin.createSingleton = caplin.singleton;
caplin.singleton = function(sClass)
{
	this.m_pSingletons.push(sClass);
};

caplin.constructSingletons = function()
{
	for(var i = 0, l = this.m_pSingletons.length; i < l; ++i)
	{
		var sSingletonClass = this.m_pSingletons[i];
		this.singletons[sSingletonClass] = eval(sSingletonClass); // from singleton-store.js
		try
		{
			this.createSingleton(sSingletonClass);
		}
		catch(e)
		{
			var sErrorMessage = "Error constructing singleton in caplin.constructSingletons, \n" + e.toString();
			
			if(console && console.error)
			{
				console.error(sErrorMessage);
			}
			
			caplin._logError(sErrorMessage, "ERROR");
		}
	}
};

caplin.m_pSingletons = [];

caplin.notifyAfterClassLoad({onAfterClassLoad:function(){
	caplin.constructSingletons();
}});
