/*
 *  Copyright 1995-2013 Caplin Systems Ltd. Do not edit this file; edits will be lost after upgrades.
 */
caplin.m_pOnAfterClassLoadListeners = [];
caplin.m_pSingletons = [];
caplin.singletons = {}; // from singleton-store.js

caplin.singleton = function(sClass)
{
	this.m_pSingletons.push(sClass);
};

caplin.notifyAfterClassLoad = function(oListener)
{
	this._validateOnAfterClassLoadListener(oListener);
	this.m_pOnAfterClassLoadListeners.push(oListener);
};

// TODO: switch code over to use caplin.core.Utility.interfaceMethod() instead?
caplin.abstractFunction = function() {
	caplin.core.Logger.log(caplin.core.LogLevel.ERROR, "invocation of unimplemented abstract function");
};

// TODO: move this functionality to the 'core' library
caplin.getFileContents = function(sFileUrl)
{
	var oXHR = caplin._getXmlHttpRequest();
	oXHR.open("GET", sFileUrl, false);
	oXHR.send("");
	
	if (oXHR.status === 200)
	{
		// if the status was OK, then evaluate the response to load the class
		return oXHR.responseText;
	}
	else
	{
		throw new Error("Unable to load file " + sFileUrl + " (status " + oXHR.status + ")");
	}
};

caplin.onLoad = function()
{
	var oListener;
	while ((oListener = this.m_pOnAfterClassLoadListeners.shift()) != undefined)
	{
		try
		{
			oListener.onAfterClassLoad();
		}
		catch(e)
		{
			this._logError("Error while invoking onAfterClassLoad() method -- skipping.");
			
			if (e.getMessage && (typeof e.getMessage === "function"))
			{
				this._logError(e.getMessage(), "ERROR");
				
				if(console && console.error)
				{
					console.error(e.getMessage());
				}
			}
		}
	}
};

// TODO: Note that these classes were copied from bootstrap-legacy.js into here
// with the aim of overriding those defined by bootstrap-lite. The issue with the 
// methods in bootstrap-lite is that they refer to caplin.* namespaces which will 
// not be included from bootstrap-lite as it's not considered a seed file.

/**
 * Returns the inner-most package object for the given package name string.
 * 
 * @param {String} sPackageName
 * @type Object
 * @return the inner most package
 */
// todo: this needs to be unit tested
caplin.getPackage = function(sPackageName)
{
	var pPackageNames = sPackageName.split(".");
	var oPackage = window;
	var sInnerPackage = '';

	if (pPackageNames.length != 1 || pPackageNames[0] != "") {
		// start at the global space (window) and work our way through the packages until we get to the innermost package
		for(var i = 0, l = pPackageNames.length; i < l; ++i)
		{			
			sInnerPackage = pPackageNames[i];
			oPackage = oPackage[sInnerPackage];
			
			if (!(oPackage instanceof Object))
			{
				var sPartialPackagePath = pPackageNames.join(".", i);
				
				throw new Error("'" + sPackageName + "' is not a valid package: failed at '" + sInnerPackage + "'.");
			}
		}
	}

	return oPackage;
};

/**
 * @deprecated Use {@link #getPackage} instead.
 * @private
 */
caplin.getObject = caplin.getPackage;


/**
 * Returns the constructor function for a class given the fully qualified class name in string form.
 * 
 * <p>This method does not actually load the class unless the <code>bLoadClass</code> argument is
 * <code>true</code>, in which case the class is loaded synchronously
 * <br>
 * Behaviour for when the class is unknown can be defined; 
 * context:name of what needs the class,
 * unknownClass: function returned instead. 
 * load: Boolean determining whether to attempt loading the class. 
 * singleton: Raise/throw error if the class isn't a singleton.
 * 
 * If no unknownClass is specified an exception will be thrown, otherwise an error will be raised.
 * <pre>
 * caplin.getClass("myapp.SomeClass") - Fetch a loaded class, which isn't a singleton, throw Error if not known.
 * caplin.getClass("myapp.SomeClass",{unknownClass:myapp.Fallback,context:"myapp"}) - Fetch loaded class, use myapp.Fallback if not known, and raise error in log.
 * </pre>
 * (see {@link caplin#include}).</p>
 * 
 * @param {String} sFullClassName The full name of the class.
 * @param {Variant} vLoadClass (Optional) <code>true</code> if this method should ensure that the
 *        specified class is loaded, otherwise <code>false</code>. If a Map is passed details about
 *        handling of unknown class must be specified.
 *        If omitted, it will default to <code>false</code>
 * @type Function
 * @return The constructor for the specified class.
 * @throws <code>Error</code> if the specified class name is not a <code>String</code>.
 */
caplin.getClass = function(sFullClassName, vLoadClass)
{
	if(typeof(sFullClassName) != "string" || sFullClassName.length <= 0)
	{
		throw new Error("caplin.getClass expects input string of length greater than 0\n");
	}
	
	// For true or false expand into object with loading boolean.
	var oLoading = caplin.getClassDefaults[vLoadClass || false] || vLoadClass;
	var sExpectedType = oLoading.singleton? "object":"function";
	
	if (oLoading.load)
	{
		caplin.include(sFullClassName, true);
	}
	
	if(sFullClassName.indexOf(".") == -1)
	{
		var oPackage = window;
		var sClassName = sFullClassName;
	}
	else
	{
		var oPackage = null;
		var sPackageName = sFullClassName.substr(0, sFullClassName.lastIndexOf("."));
		var sClassName = sFullClassName.substr(sFullClassName.lastIndexOf(".") + 1);
		
		try
		{
			oPackage = this.getPackage(sPackageName);
		}
		catch(e)
		{
			throw new Error("'" + sFullClassName + "' unknown as package does not exist\n" + e.toString());
		}
	}

	// Early resolution to optimise the common case
	var fClass = oPackage[sClassName];
	if (typeof fClass == sExpectedType && oLoading.singleton == (fClass.prototype == undefined)) {
		return fClass;
	}
		
	var sMessage = sFullClassName + ": class not known";
	var sMessageSingleton = sFullClassName + ": class must be a singleton";
	if (oLoading.context) {
		sMessage += ", needed by "+oLoading.context;
		sMessageSingleton += " when used by "+oLoading.context;
	}
	sMessage += ". It may need to be added to resources.xml";
	
	fClass = oPackage[sClassName];

	if(typeof(fClass) != sExpectedType)
	{
		if (oLoading.singleton && fClass.prototype != undefined) {
			if (oLoading.unknownClass) {
				caplin.core.Logger.log(caplin.core.LogLevel.ERROR, sMessageSingleton);
				return oLoading.unknownClass;
			}
			throw new Error(sMessageSingleton);		
		}
		
		if (oLoading.unknownClass) {
			caplin.core.Logger.log(caplin.core.LogLevel.ERROR, sMessage);
			return oLoading.unknownClass;
		}
		throw new Error(sMessage);		
	}
	
	return fClass;
};


caplin._getXmlHttpRequest = function()
{
	var oReqObj = false;
	
	if(window.XMLHttpRequest)
	{
		// branch for native XMLHttpRequest object
		try
		{
			oReqObj = new XMLHttpRequest();
			/**
			 * FF3 issue: associate a unique index with each XHR object, which is later used for
			 * cross checking to make sure no mix-up occurs
			 */
			oReqObj.i = caplin._nXhrIdx++;
		}
		catch(e)
		{
			oReqObj = false;
		}
	}
	else if(window.ActiveXObject)
	{
		// branch for IE/Windows ActiveX version
		// WARNING: native library replaces the ActiveXObject for purposes of controlling which XMLHTTP object is created.
		try
		{
			oReqObj = new ActiveXObject("Msxml2.XMLHTTP");
		}
		catch(e)
		{
			try
			{
				oReqObj = new ActiveXObject("Microsoft.XMLHTTP");
			}
			catch(e)
			{
				oReqObj = false;
			}
		}
	}
	
	return oReqObj;
};

caplin._createSingleton = function(sClass)
{
	if(typeof(sClass) != "string")
	{
		throw new Error("Class parameter must be a string.");
	}
	
	var nLastDotIndex = sClass.lastIndexOf(".");
	var sPackageName = sClass.substr(0, nLastDotIndex);
	var sClassName = sClass.substr(nLastDotIndex + 1);
	var fClass = caplin.getObject(sClass);
	
	if (typeof fClass == "function")
	{
		var oPackage = caplin.getObject(sPackageName);
		
		// need to store all of the statics added to the class as the following assignment will wipe
		// them out
		var mStaticsToPort = {};
		for (var sStaticName in fClass)
		{
			// ignore prototype - port over all other statics
			if (sStaticName != "prototype")
			{
				mStaticsToPort[sStaticName] = fClass[sStaticName];
			}
		}
		
		oPackage[sClassName] = new fClass();
		
		// now add the statics back in
		for (sStaticName in mStaticsToPort)
		{
			oPackage[sClassName][sStaticName] = mStaticsToPort[sStaticName];
		}
	}
	else
	{
		throw new Error("Class \"" + sClass + "\" is already a singleton object");
	}
};

caplin._validateOnAfterClassLoadListener = function(oListener)
{
	if (!oListener || typeof oListener.onAfterClassLoad != "function")
	{
		throw new Error("Specified listener does not implement an onAfterClassLoad() method");
	}
};

caplin._constructSingletons = function()
{
	for(var i = 0, l = this.m_pSingletons.length; i < l; ++i)
	{
		var sSingletonClass = this.m_pSingletons[i];
		this.singletons[sSingletonClass] = eval(sSingletonClass); // from singleton-store.js
		try
		{
			this._createSingleton(sSingletonClass);
		}
		catch(e)
		{
			var sErrorMessage = "Error constructing singleton in caplin.constructSingletons, \n" + e.toString();
			
			if(console && console.error)
			{
				console.error(sErrorMessage);
			}
			
			caplin._logError(sErrorMessage, "ERROR");
		}
	}
};

caplin.notifyAfterClassLoad({onAfterClassLoad:function(){
	caplin._constructSingletons();
}});
