<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Emitter.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: Emitter.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/*global module*/
var Emitter = null;
(function() {
	"use strict";
	var slice = Array.prototype.slice;
	var global = Function("return this;")();

	// Partial shim for es6 Map ///////////////////////////////////////////////////////
	var Map = global.Map;

	// Uses a map for string keys and two arrays for nonstring keys.
	// Another alternative would have been to add a nonenumerable id to everything that was set.
	function MapShim() {
		this._map = [];
		this._keys = [];
		this._values = [];
	}
	MapShim.prototype = {
		'set': function set(key, value) {
			if (typeof key === 'string') {
				this._map[key] = value;
				return value;
			}
			var idx = this._keys.indexOf(key);
			if (idx &lt; 0) {
				idx = this._keys.length;
				this._keys[idx] = key;
			}
			this._values[idx] = value;
			return value;
		},
		'get': function get(key) {
			if (typeof key === 'string') {
				return this._map[key];
			}
			return this._values[this._keys.indexOf(key)];
		},
		'delete': function(key) {
			if (typeof key === 'string') {
				delete this._map[key];
				return;
			}
			var idx = this._keys.indexOf(key);
			if (idx >= 0) {
				this._keys.splice(idx, 1);
				this._values.splice(idx, 1);
			}
		},
		'has': function(key) {
			return (typeof key === 'string' && key in this._map) || (this._keys.indexOf(key) >= 0);
		},
		'forEach': function(callback) {
			for (var key in this._map) {
				// this._map is a map with no inherited properties
				// (unless someone has modified Object.prototype with enumerable
				// properties, in which case they deserve what they get).
				//noinspection JSUnfilteredForInLoop
				callback(this._map[key], key, this);
			}
			for (var i = this._keys.length - 1; i >= 0; --i) {
				callback(this._values[i], this._keys[i], this);
			}
		}
	};

	if (Map === undefined) {
		Map = MapShim;
	}

	/////////////////////////////////////////////////////////////////////////////////////////
	function MultiMap() {
		this._map = new Map();
	}
	MultiMap.prototype = {
		'getValues': function getValues(key) {
			var val;
			if (arguments.length === 0) {
				// return all values for all keys.
				val = [];
				this._map.forEach(function(values) {
					val.push.apply(val, values);
				});
			} else {
				// return all the values for the provided key.
				val = this._map.get(key);
				if (val === undefined) {
					val = [];
					this._map.set(key, val);
				}
			}
			return val;
		},
		'clear': function clear() {
			this._map = new Map();
		},
		'add': function add(key, value) {
			this.getValues(key).push(value);
		},
		'filter': function filter(key, filterFunction) {
			if (this._map.has(key) === false) { return; }

			var values = this._map.get(key).filter(filterFunction);

			if (values.length === 0) {
				this._map.delete(key);
			} else {
				this._map.set(key, values);
			}
		},
		'filterAll': function(filterFunction) {
			this._map.forEach(function(values, key, map) {
				var newValues = values.filter(filterFunction);
				if (newValues.length === 0) {
					map.delete(key);
				} else {
					map.set(key, newValues);
				}
			});
		},
		'removeLastMatch': function removeLast(key, matchFunction) {
			if (this._map.has(key) === false) { return false; }
			var values = this._map.get(key);
			for (var i = values.length - 1; i >= 0; --i) {
				if (matchFunction(values[i])) {
					values.splice(i, 1);
					return true;
				}
			}
			return false;
		},
		'hasAny': function has(key) {
			return this._map.has(key);
		},
		'delete': function del(key) {
			this._map.delete(key);
		}
	};


	///////////////////////////////////////////////////////////////////////////
	function notify(listeners, args) {
		if (listeners.length === 0) { return false; }
		// take a copy in case one of the callbacks modifies the listeners array.
		listeners = listeners.slice();
		for (var i = 0, len = listeners.length; i &lt; len; ++i) {
			var listener = listeners[i];
			listener.callback.apply(listener.context, args);
		}
		return true;
	}

	function notifyRemoves(emitter, listenerRecords) {
		for (var i = 0, len = listenerRecords.length; i &lt; len; ++i) {
			var listenerRecord = listenerRecords[i];
			emitter.trigger(new RemoveListenerEvent(listenerRecord.eventIdentifier, listenerRecord.callback, listenerRecord.registeredContext));
		}
	}

	// This is private, and never revealed, which should stop anyone from faking a function wrapper.
	var ONCE_FUNCTION_MARKER = {};

	/**
	 * This constructor function can be used directly, but most commonly, you will
	 * call it from within your own constructor.
	 *
	 * e.g. &lt;code>Emitter.call(this);&lt;/code>
	 *
	 * It will set up the emitter state if called, but it is optional.
	 *
	 * @constructor
	 * @class Emitter
	 * @classdesc
	 * Emitter provides event emitting capabilities, similar to Backbone.
	 * For more information see &lt;a href="http://kybernetikos.github.io/Emitter">the project page&lt;/a>.
	 */
	Emitter = function Emitter() {
		this._emitterListeners = new MultiMap();
		this._emitterMetaEventsOn = false;
	};

	Emitter.prototype = {
		/**
		 * Registers a listener for an event.
		 *
		 * If context is provided, then the &lt;code>this&lt;/code> pointer will refer to it
		 * inside the callback.
		 *
		 * @param {*} eventIdentifier The identifier of the event that the callback should listen to.
		 * @param {function} callback The function that should be called whenever the event is triggered.  May not be null.
		 * @param {?Object} [context] An optional context that defines what 'this' should be inside the callback.
		 */
		on: function listen(eventIdentifier, callback, context) {
			if (typeof callback !== 'function') { throw new TypeError("on: Illegal Argument: callback must be a function, was " + (typeof callback)); }

			// This allows us to work even if the constructor hasn't been called.  Useful for mixins.
			if (this._emitterListeners === undefined) {
				this._emitterListeners = new MultiMap();
			}

			if (typeof eventIdentifier === 'function' && (eventIdentifier.prototype instanceof  MetaEvent || eventIdentifier === MetaEvent)) {
				// Since triggering meta events can be expensive, we only
				// do so if a listener has been added to listen to them.
				this._emitterMetaEventsOn = true;
			}

			this._emitterListeners.add(eventIdentifier, {
				eventIdentifier: eventIdentifier,
				callback: callback,
				registeredContext: context,
				context: context !== undefined ? context : this
			});

			if (this._emitterMetaEventsOn === true) {
				this.trigger(new AddListenerEvent(eventIdentifier, callback._onceFunctionMarker === ONCE_FUNCTION_MARKER ? callback._wrappedCallback : callback, context));
			}
		},

		/**
		 * Registers a listener to receive an event only once.
		 *
		 * If context is provided, then the &lt;code>this&lt;/code> pointer will refer to it
		 * inside the callback.
		 *
		 * @param {*} eventIdentifier The identifier of the event that the callback should listen to.
		 * @param {function} callback The function that should be called the first time the event is triggered.  May not be null.
		 * @param {?Object} [context] An optional context that defines what 'this' should be inside the callback.
		 */
		once: function(eventIdentifier, callback, context) {
			if (typeof callback !== 'function') { throw new TypeError("on: Illegal Argument: callback must be a function, was " + (typeof callback)); }

			var off = this.off.bind(this), hasFired = false;

			function onceEventHandler() {
				if (hasFired === false) {
					hasFired = true;
					off(eventIdentifier, onceEventHandler, context);
					callback.apply(this, arguments);
				}
			}
			// We need this to enable us to remove the wrapping event handler
			// when off is called with the original callback.
			onceEventHandler._onceFunctionMarker = ONCE_FUNCTION_MARKER;
			onceEventHandler._wrappedCallback = callback;

			this.on(eventIdentifier, onceEventHandler, context);
		},

		/**
		 * Clear previously registered listeners.
		 *
		 * With no arguments, this clears all listeners from this Emitter.
		 *
		 * With one argument, this clears all listeners registered to a particular event.
		 *
		 * With two or three arguments, this clears a specific listener.
		 *
		 * @param {?*} eventIdentifier The identifier of the event to clear. If null, it will clear all events.
		 * @param {?function} callback The callback function to clear.
		 * @param {?Object} context The context object for the callback.
		 * @returns {boolean} true if any listeners were removed.  This is not finalised yet and may change (particularly if we want to enable chaining).
		 */
		off: function off(eventIdentifier, callback, context) {
			// not initialised - so no listeners of any kind
			if (this._emitterListeners == null) { return false; }

			if (arguments.length === 0) {
				// clear all listeners.
				if (this._emitterMetaEventsOn === true) {
					var allListeners = this._emitterListeners.getValues();
					notifyRemoves(this, allListeners);
				}
				this._emitterListeners.clear();
				return true;
			} else if (arguments.length === 1) {
				// clear all listeners for a particular eventIdentifier.
				if (this._emitterListeners.hasAny(eventIdentifier)) {
					var listeners = this._emitterListeners.getValues(eventIdentifier);
					this._emitterListeners.delete(eventIdentifier);
					if (this._emitterMetaEventsOn === true) {
						notifyRemoves(this, listeners);
					}
					return true;
				}
				return false;
			} else if (eventIdentifier === null && callback === null) {
				// clear all listeners for a particular context.
				return this.clearListeners(context);
			} else {
				// clear a specific listener.
				if (typeof callback !== 'function') { throw new TypeError("off: Illegal Argument: callback must be a function, was " + (typeof callback)); }

				var removedAListener = this._emitterListeners.removeLastMatch(eventIdentifier, function(record) {
					var callbackToCompare = record.callback._onceFunctionMarker === ONCE_FUNCTION_MARKER ? record.callback._wrappedCallback : record.callback;
					var callbackMatches = callback === callbackToCompare;
					var contextMatches = record.registeredContext === context;
					return callbackMatches && contextMatches;
				});

				if (removedAListener && this._emitterMetaEventsOn === true) {
					this.trigger(new RemoveListenerEvent(eventIdentifier, callback, context));
				}
				return removedAListener;
			}
		},

		/**
		 * Fires an event, causing all the listeners registered for this event to be called.
		 *
		 * If the event is an object, this will also call any listeners registered for
		 * its class or any superclasses will also fire.
		 *
		 * @param {*} event The event to fire.
		 * @param {...*} [args] Optional arguments to pass to the listeners.
		 * @returns {boolean} true if any listeners were notified, false otherwise.  This is not finalised and may change (particularly if we want to allow chaining).
		 */
		trigger: function trigger(event, args) {
			var anyListeners = false;
			if (this._emitterListeners != null) {
				args = slice.call(arguments, 1);
				if (this._emitterListeners.hasAny(event)) {
					anyListeners = true;
					notify(this._emitterListeners.getValues(event), args);
				}

				// navigate up the prototype chain emitting against the constructors.
				if (typeof event === 'object') {
					var last = event, proto = Object.getPrototypeOf(event);
					while (proto !== null && proto !== last) {
						if (this._emitterListeners.hasAny(proto.constructor)) {
							anyListeners = true;
							notify(this._emitterListeners.getValues(proto.constructor), arguments);
						}
						last = proto;
						proto = Object.getPrototypeOf(proto);
					}
				}
			}
			if (this._emitterMetaEventsOn === true && anyListeners === false && event instanceof DeadEvent === false) {
				this.trigger(new DeadEvent(event, args));
			}
			return anyListeners;
		},

		/**
		 * Clears all listeners registered for a particular context.
		 *
		 * @param {Object} context The context that all listeners should be removed for.  May not be null.
		 */
		clearListeners: function clearListeners(context) {
			if (context == null) { throw new Error('clearListeners: context must be provided.'); }
			// notify for every listener we throw out.
			var removedListeners, trackRemovals = false;
			if (this._emitterMetaEventsOn === true) {
				trackRemovals = true;
				removedListeners = [];
			}
			this._emitterListeners.filterAll(function(record) {
				var keepListener = record.registeredContext !== context;
				if (trackRemovals && keepListener === false) {
					removedListeners.push(record);
				}
				return keepListener;
			});
			if (trackRemovals && removedListeners.length > 0) {
				notifyRemoves(this, removedListeners);
			}
		}
	};

	/**
	 * Copies the Emitter methods onto the provided object.
	 *
	 * If the passed destination is a function, it copies the methods
	 * onto the prototype of the passed destination.
	 *
	 * @param {function|Object} destination the object to copy the Emitter
	 *    methods to or the constructor that should have its prototype
	 *    augmented with the Emitter methods.
	 */
	Emitter.mixInto = function(destination) {
		if (typeof destination === 'function') {
			destination = destination.prototype;
		}
		for (var key in Emitter.prototype) {
			// If in the future Emitter is changed to inherit from something,
			// we would want to copy those methods/properties too.
			//noinspection JSUnfilteredForInLoop
			if (destination.hasOwnProperty(key)) {
				throw new Error("Emitter.mixInto: Destination already has function " + key + " unable to mixin.");
			}
			//noinspection JSUnfilteredForInLoop
			destination[key] = Emitter.prototype[key];
		}
	};

	// Event and MetaEvent Hierarchy ///////////////////////////////////////////////////////

	/**
	 * Creates a base Event object.
	 * @constructor
	 * @memberOf Emitter
	 * @class Event
	 * @classdesc
	 * Event provides a convenient base class for events.
	 */
	var Event = function() {};

	/**
	 * Extend provides a shorthand for creating subclasses of the class
	 * whose constructor it is attached to.
	 *
	 * You can pass in an object that represents the things that
	 * should be added to the prototype (in which case, the special
	 * member 'constructor' if present will become the constructor),
	 * or a function that represents the constructor whose prototype
	 * should be modified, or nothing at all, in which case a new
	 * constructor will be created that calls the superclass constructor.
	 *
	 * @memberOf Emitter.Event
	 * @param {object|function} [descriptor] an object containing methods to be added to the prototype, or the constructor function, or nothing at all.
	 * @returns {function} a constructor function for the newly created subclass.
	 */
	Event.extend = function inlineExtend(properties) {
		var superclass = this, subclassConstructor;
		if (typeof superclass !== 'function') { throw new TypeError("extend: Superclass must be a constructor function, was a " + typeof superclass); }

		if (typeof properties === 'function') {
			subclassConstructor = properties;
		} else if (properties != null && properties.hasOwnProperty('constructor')) {
			subclassConstructor = properties.constructor;
		} else {
			subclassConstructor = function() {
				superclass.apply(this, arguments);
			};
		}
		subclassConstructor.prototype = Object.create(superclass.prototype, {
			constructor: {
				enumerable: false, value: subclassConstructor
			}
		});

		if (typeof properties === 'object') {
			if (Object.getPrototypeOf(properties) === Object.prototype) {
				throw new Error("extend: Can't extend something that already has a prototype chain.");
			}
			for (var instanceProperty in properties) {
				if (instanceProperty !== 'constructor') {
					// We've already checked that properties doesn't inherit from anything
					// except Object, and if someone is changing the Object.prototype with
					// enumerable properties, then they deserve what they get.
					//noinspection JSUnfilteredForInLoop
					subclassConstructor.prototype[instanceProperty] = properties[instanceProperty];
				}
			}
		}
		for (var staticProperty in superclass) {
			if (superclass.hasOwnProperty(staticProperty)) {
				subclassConstructor[staticProperty] = superclass[staticProperty];
			}
		}

		return subclassConstructor;
	};
	/**
	 * A simple toString is provided to aid in debuging.
	 * @returns {string} a representation of all the fields on the object.
	 */
	Event.prototype.toString = function() {
		var result = [];
		for (var key in this) {
			// toString should show inherited properties too.
			//noinspection JSUnfilteredForInLoop
			if (typeof result[key] !== 'function') {
				//noinspection JSUnfilteredForInLoop
				result.push(key + ": " + this[key] + ",");
			}
		}
		return result.join(" ");
	};

	Emitter.Event = Event;

	var MetaEvent = Event.extend(
		/**
		 * @memberOf Emitter.meta
		 * @class MetaEvent
		 * @param {*} event The event this MetaEvent is about
		 * @classdesc
		 * A parent class for all meta events.
		 */
		function(event) {
			/**
			 * Event provides the identifier of the event that this MetaEvent is about.
			 * @name Emitter.meta.MetaEvent#event
			 * @type {*}
			 */
			this.event = event;
		}
	);
	/**
	 * @memberOf Emitter.meta
	 * @extends Emitter.meta.MetaEvent
	 * @class ListenerEvent
	 * @classdesc
	 * A parent class for all MetaEvents about listeners.
	 */
	var ListenerEvent = MetaEvent.extend(
		function(event, listener, context) {
			MetaEvent.call(this, event);
			/**
			 * The listener this ListenerEvent is about.
			 * @name Emitter.meta.ListenerEvent#listener
			 * @type {function}
			 */
			this.listener = listener;
			/**
			 * The context associated with the listener.
			 * @name Emitter.meta.ListenerEvent#context
			 * @type {?object}
			 */
			this.context = context;
		}
	);
	/**
	 * @memberOf Emitter.meta
	 * @class AddListenerEvent
	 * @extends Emitter.meta.ListenerEvent
	 */
	var AddListenerEvent = ListenerEvent.extend();
	/**
	 * @memberOf Emitter.meta
	 * @class RemoveListenerEvent
	 * @extends Emitter.meta.ListenerEvent
	 */
	var RemoveListenerEvent = ListenerEvent.extend();
	/**
	 * @memberOf Emitter.meta
	 * @class DeadEvent
	 * @extends Emitter.meta.MetaEvent
	 */
	var DeadEvent = MetaEvent.extend(
		function(event, args) {
			MetaEvent.call(this, event);
			this.data = args;
		}
	);

	/**
	 * Where the meta events live.
	 * @memberOf Emitter
	 * @namespace meta
	 */
	Emitter.meta = {
		MetaEvent: MetaEvent,
		ListenerEvent: ListenerEvent,
		AddListenerEvent: AddListenerEvent,
		RemoveListenerEvent: RemoveListenerEvent,
		DeadEvent: DeadEvent
	};
})();

if (typeof module !== 'undefined') {
	module.exports = Emitter;
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="Emitter.html">Emitter</a></li><li><a href="Emitter.Event.html">Event</a></li><li><a href="Emitter.meta.AddListenerEvent.html">AddListenerEvent</a></li><li><a href="Emitter.meta.DeadEvent.html">DeadEvent</a></li><li><a href="Emitter.meta.ListenerEvent.html">ListenerEvent</a></li><li><a href="Emitter.meta.MetaEvent.html">MetaEvent</a></li><li><a href="Emitter.meta.RemoveListenerEvent.html">RemoveListenerEvent</a></li></ul><h3>Namespaces</h3><ul><li><a href="Emitter.meta.html">meta</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0-dev</a> on Thu Aug 15 2013 09:32:36 GMT+0100 (BST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
